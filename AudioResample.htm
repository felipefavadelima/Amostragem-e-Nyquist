<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Reamostragem e Quantização de Áudio (.wav)</title>
</head>
<body style="margin:0;background:#0f1420">
  <div id="root"></div>

  <!-- React 18 e ReactDOM 18 em UMD -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel para transpilar JSX no navegador -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- App -->
  <script type="text/babel">
    const { useState, useRef, useEffect } = React;

    function App() {
      const [fileName, setFileName] = useState(null);
      const [audioInfo, setAudioInfo] = useState(null);
      const [targetFs, setTargetFs] = useState(8000);
      const [nBits, setNBits] = useState(8);

      const [status, setStatus] = useState('Selecione um arquivo .wav para começar.');
      const [isBusy, setIsBusy] = useState(false);

      const fileInputRef = useRef(null);
      const decodeCtxRef = useRef(null);
      const playCtxRef = useRef(null);
      const srcNodeRef = useRef(null);
      const originalBufferRef = useRef(null);

      function clamp(v, lo, hi) {
        if (Number.isNaN(v)) return lo;
        return Math.max(lo, Math.min(hi, v));
      }

      function stopPlayback() {
        try {
          if (srcNodeRef.current) srcNodeRef.current.stop();
        } catch (_) {}
        srcNodeRef.current = null;
      }

      function ensurePlayContext() {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (!AC) return null;
        if (playCtxRef.current && playCtxRef.current.state === 'closed') {
          playCtxRef.current = null;
        }
        if (!playCtxRef.current) {
          playCtxRef.current = new AC();
        }
        return playCtxRef.current;
      }

      useEffect(() => {
        return () => {
          stopPlayback();
          if (decodeCtxRef.current) {
            try { decodeCtxRef.current.close(); } catch (_) {}
          }
          if (playCtxRef.current) {
            try { playCtxRef.current.close(); } catch (_) {}
          }
        };
      }, []);

      async function handleFileChange(e) {
        const file = e.target.files && e.target.files[0];
        if (!file) return;

        stopPlayback();
        if (decodeCtxRef.current) {
          try { await decodeCtxRef.current.close(); } catch (_) {}
          decodeCtxRef.current = null;
        }

        setStatus("Carregando arquivo...");
        setIsBusy(true);

        try {
          const arrayBuffer = await file.arrayBuffer();
          const AC = window.AudioContext || window.webkitAudioContext;
          if (!AC) {
            setStatus("Este navegador não suporta Web Audio API.");
            setIsBusy(false);
            return;
          }
          const ctx = new AC();
          decodeCtxRef.current = ctx;

          const audioBuffer = await ctx.decodeAudioData(arrayBuffer);
          originalBufferRef.current = audioBuffer;

          setAudioInfo({
            sampleRate: audioBuffer.sampleRate,
            duration: audioBuffer.duration,
            channels: audioBuffer.numberOfChannels
          });

          setFileName(file.name);
          // valor inicial razoável
          setTargetFs(Math.max(1000, Math.min(48000, audioBuffer.sampleRate)));

          setStatus("Arquivo carregado.");
        } catch (err) {
          console.error(err);
          setStatus("Erro ao carregar arquivo.");
        } finally {
          setIsBusy(false);
        }
      }

      async function handlePlayOriginal() {
        const buffer = originalBufferRef.current;
        if (!buffer) {
          setStatus("Nenhum arquivo carregado.");
          return;
        }

        const ctx = ensurePlayContext();
        if (!ctx) {
          setStatus("Este navegador não suporta Web Audio API.");
          return;
        }

        stopPlayback();

        try {
          const src = ctx.createBufferSource();
          src.buffer = buffer;
          src.connect(ctx.destination);
          src.start();
          srcNodeRef.current = src;
          setStatus("Reproduzindo áudio original.");
        } catch (err) {
          console.error(err);
          setStatus("Erro ao reproduzir o áudio.");
        }
      }

      async function handlePlayProcessed() {
        const buffer = originalBufferRef.current;
        if (!buffer) {
          setStatus("Nenhum arquivo carregado.");
          return;
        }

        const ctx = ensurePlayContext();
        if (!ctx) {
          setStatus("Este navegador não suporta Web Audio API.");
          return;
        }

        const fs0 = buffer.sampleRate;       // taxa do arquivo
        const fsPlay = ctx.sampleRate;       // taxa do contexto (hardware)
        const fsTargetRaw = Number(targetFs) || 8000;

        // fs "desejada" para o ADC (conceitual)
        const fsTargetClamped = clamp(fsTargetRaw, 200, fs0);

        // fator de dizimação inteiro para simular amostragem em fsADC
        const r = Math.max(1, Math.round(fs0 / fsTargetClamped));
        const fsEff = fs0 / r;   // taxa de amostragem efetiva do ADC

        stopPlayback();
        setIsBusy(true);
        setStatus("Processando áudio (dizimação sem filtro + quantização)...");

        try {
          const length = buffer.length;
          const channels = buffer.numberOfChannels;

          // número de amostras que o contexto vai tocar
          const Nplay = Math.max(1, Math.round(buffer.duration * fsPlay));

          const bits = clamp(Number(nBits) || 8, 2, 24);
          const maxInt = Math.pow(2, bits - 1) - 1;

          const processed = ctx.createBuffer(channels, length, fs0);

          for (let ch = 0; ch < channels; ch++) {
            const inData = buffer.getChannelData(ch);
            const outData = processed.getChannelData(ch);

            // Para cada amostra em fs0, escolhemos uma amostra "dizimada" x[k] = x[k*r]
            // e repetimos essa amostra por r pontos (zero-order hold).
            for (let n = 0; n < length; n++) {
              const k = Math.floor(n / r);
              const idx = Math.min(k * r, length - 1);
              let v = inData[idx];

              // quantização em n bits
              if (v > 1) v = 1;
              else if (v < -1) v = -1;
              const q = Math.round(v * maxInt) / maxInt;

              outData[n] = q;
            }
          }

          const src = ctx.createBufferSource();
          src.buffer = processed;             // fs0 → reproduzido em fsPlay com resampling interno
          src.connect(ctx.destination);
          src.start();
          srcNodeRef.current = src;

          setStatus(
            `Reproduzindo processado: fs pedido ≈ ${fsTargetClamped.toFixed(0)} Hz, ` +
            `fs efetiva = ${(fsEff).toFixed(0)} Hz, ${bits} bits.`
          );
        } catch (err) {
          console.error(err);
          setStatus("Erro ao processar o áudio.");
        } finally {
          setIsBusy(false);
        }
      }

      const minFsUi = 200;
      const maxFsUi = 48000;

      return (
        <div className="wrap">
          <style>{`
            :root {
              --bg:#0f1420;
              --panel:#151b2a;
              --ink:#e8eefc;
              --ink-dim:#a8b2c8;
              --accent:#4da3ff;
            }
            * { box-sizing:border-box; }
            body {
              margin:0;
              font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto;
              background:var(--bg);
              color:var(--ink);
            }
            .wrap { max-width:1100px; margin:0 auto; padding:20px; }
            h1 { text-align:center; font-size:20px; margin-bottom:4px; }
            .subtitle { text-align:center; color:var(--ink-dim); margin-bottom:14px; }
            .panel {
              background:var(--panel);
              border:1px solid #1b2235;
              border-radius:10px;
              padding:14px;
              box-shadow:0 6px 18px rgba(0,0,0,.25);
            }
            .control {
              margin:12px 0;
              padding:10px;
              background:#121828;
              border-radius:10px;
              border:1px solid #1b2235;
            }
            .actions { display:flex; gap:10px; margin-top:14px; flex-wrap:wrap; }
            .btn {
              padding:8px 16px;
              border-radius:999px;
              border:1px solid #273453;
              background:#1a2236;
              color:white;
              cursor:pointer;
            }
            .btn-primary {
              background:linear-gradient(135deg,#2563eb,#38bdf8);
            }
            .btn[disabled] {
              opacity:0.6;
              cursor:not-allowed;
            }
            input[type=range] { width:100%; accent-color:var(--accent); }
            input[type=number] {
              width:90px;
              padding:6px;
              border-radius:6px;
              border:1px solid #273453;
              background:#0e1424;
              color:white;
            }
            .status { margin-top:12px; color:var(--ink-dim);}
            .meta {
              margin-top:8px;
              display:flex;
              flex-wrap:wrap;
              gap:8px;
              font-size:13px;
              color:var(--ink-dim);
            }
            .pill {
              background:#10172a;
              border:1px solid #273453;
              padding:4px 8px;
              border-radius:999px;
            }
          `}</style>

          <h1>Reamostragem e Quantização de Áudio (.wav)</h1>
          <div className="subtitle">
            Carregue um .wav e ouça como ele soaria se fosse amostrado em outra frequência (sem antialias) e com menos bits.
          </div>

          <div className="panel">

            <div className="control">
              <label>Selecione um arquivo .wav</label><br/>
              <input
                ref={fileInputRef}
                type="file"
                accept=".wav,audio/wav"
                onChange={handleFileChange}
                style={{ marginTop:"6px" }}
              />
              <div style={{ marginTop:"6px", color:"var(--ink-dim)" }}>
                {fileName ?? "Nenhum arquivo selecionado"}
              </div>
              {audioInfo && (
                <div className="meta">
                  <span className="pill">fs arquivo: {audioInfo.sampleRate.toFixed(0)} Hz</span>
                  <span className="pill">canais: {audioInfo.channels}</span>
                  <span className="pill">
                    duração: {audioInfo.duration.toFixed(2)} s
                  </span>
                </div>
              )}
            </div>

            <div className="control">
              <label>Frequência de amostragem do ADC (Hz, sem antialias)</label>
              <input
                type="range"
                min={minFsUi}
                max={maxFsUi}
                step="100"
                value={targetFs}
                onChange={(e)=>setTargetFs(Number(e.target.value))}
              />
              <input
                type="number"
                min={minFsUi}
                max={maxFsUi}
                step="100"
                value={targetFs}
                onChange={(e)=>setTargetFs(clamp(Number(e.target.value), minFsUi, maxFsUi))}
              />
            </div>

            <div className="control">
              <label>Resolução do ADC (bits)</label>
              <input
                type="range"
                min="2"
                max="24"
                step="1"
                value={nBits}
                onChange={(e)=>setNBits(Number(e.target.value))}
              />
              <input
                type="number"
                min="2"
                max="24"
                step="1"
                value={nBits}
                onChange={(e)=>setNBits(clamp(Number(e.target.value), 2, 24))}
              />
            </div>

            <div className="actions">
              <button className="btn" onClick={handlePlayOriginal} disabled={!originalBufferRef.current || isBusy}>
                Ouvir original
              </button>

              <button className="btn btn-primary" onClick={handlePlayProcessed} disabled={!originalBufferRef.current || isBusy}>
                Ouvir com nova configuração
              </button>
            </div>

            <div className="status">{status}</div>

          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
