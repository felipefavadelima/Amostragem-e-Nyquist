<!doctype html>
<html lang="pt-BR" data-theme="light">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Amostragem no domínio da Frequência — 3 cossenoides + áudio</title>

  <script>
    (function () {
      document.documentElement.setAttribute('data-theme', 'light');
    })();
  </script>
</head>
<body>
  <div id="root"></div>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState, useCallback } = React

    // =====================
    // Canvas helpers
    // =====================
    function useCanvas(ref, draw) {
      useEffect(() => {
        const onResize = () => draw()
        window.addEventListener('resize', onResize)
        draw()
        return () => window.removeEventListener('resize', onResize)
      }, [draw])
    }

    function fitCanvas(canvas) {
      const dpr = window.devicePixelRatio || 1
      const cw = canvas.clientWidth || 800
      const ch = canvas.clientHeight || 320
      canvas.width  = Math.round(cw * dpr)
      canvas.height = Math.round(ch * dpr)
      const ctx = canvas.getContext('2d')
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0)
      return { ctx, W: cw, H: ch }
    }

    function getCSSVar(name) {
      return getComputedStyle(document.documentElement).getPropertyValue(name).trim()
    }

    function drawGrid(ctx, W, H, pad, xTicks=6, yTicks=6) {
      const bg = getCSSVar('--canvas')
      const gridV = getCSSVar('--gridV')
      const gridH = getCSSVar('--gridH')
      const frame = getCSSVar('--frame')

      ctx.fillStyle = bg
      ctx.fillRect(0,0,W,H)

      ctx.strokeStyle = gridV
      ctx.lineWidth = 1
      for (let i=0;i<xTicks;i++){
        const x = pad.l + (W-pad.l-pad.r)*(i/(xTicks-1))
        ctx.beginPath(); ctx.moveTo(x,pad.t); ctx.lineTo(x,H-pad.b); ctx.stroke()
      }

      ctx.strokeStyle = gridH
      ctx.lineWidth = 1
      for (let i=0;i<yTicks;i++){
        const y = pad.t + (H-pad.t-pad.b)*(i/(yTicks-1))
        ctx.beginPath(); ctx.moveTo(pad.l,y); ctx.lineTo(W-pad.r,y); ctx.stroke()
      }

      ctx.strokeStyle = frame
      ctx.strokeRect(pad.l, pad.t, W-pad.l-pad.r, H-pad.t-pad.b)
    }

    function makeScales(W, H, pad, xMin, xMax, yMin, yMax) {
      const xScale = x => pad.l + (W-pad.l-pad.r) * ((x - xMin) / (xMax - xMin || 1))
      const yScale = y => {
        const p = (y - yMin) / (yMax - yMin || 1)
        return H - pad.b - p*(H-pad.t-pad.b)
      }
      const xInv = px => xMin + ((px - pad.l) / (W-pad.l-pad.r)) * (xMax-xMin)
      return { xScale, yScale, xInv }
    }

    function drawAxesLabels(ctx, W, H, pad, xLabel, yLabel) {
      const inkDim = getCSSVar('--inkDim')
      ctx.fillStyle = inkDim
      ctx.font = '12px system-ui, sans-serif'

      ctx.textAlign = 'right'
      ctx.fillText(xLabel, W-8, H-10)

      ctx.save()
      ctx.translate(14, pad.t + (H-pad.t-pad.b)/2)
      ctx.rotate(-Math.PI/2)
      ctx.textAlign = 'center'
      ctx.fillText(yLabel, 0, 0)
      ctx.restore()
    }

    function drawNumericAxes(ctx, W, H, pad, xMin, xMax, yMin, yMax, xTicks=6, yTicks=6) {
      const inkDim = getCSSVar('--inkDim')
      const frame = getCSSVar('--frame')
      ctx.font = '12px system-ui, sans-serif'
      ctx.fillStyle = inkDim
      ctx.strokeStyle = frame
      ctx.lineWidth = 1

      const { xScale, yScale } = makeScales(W, H, pad, xMin, xMax, yMin, yMax)

      // X ticks
      ctx.textAlign = 'center'
      ctx.textBaseline = 'top'
      for (let i=0;i<xTicks;i++){
        const t = i/(xTicks-1)
        const xv = xMin + t*(xMax-xMin)
        const x = xScale(xv)
        const y0 = H - pad.b
        ctx.beginPath(); ctx.moveTo(x, y0); ctx.lineTo(x, y0+5); ctx.stroke()
        const txt =
          (Math.abs(xv) < 1e-12) ? '0'
          : (Math.abs(xv) < 1 ? xv.toFixed(4)
          : (Math.abs(xv) < 10 ? xv.toFixed(3)
          : (Math.abs(xv) < 100 ? xv.toFixed(2) : xv.toFixed(0))))
        ctx.fillText(txt, x, y0+7)
      }

      // Y ticks
      ctx.textAlign = 'right'
      ctx.textBaseline = 'middle'
      for (let i=0;i<yTicks;i++){
        const t = i/(yTicks-1)
        const yv = yMin + (1-t)*(yMax-yMin)
        const y = yScale(yv)
        const x0 = pad.l
        ctx.beginPath(); ctx.moveTo(x0-5, y); ctx.lineTo(x0, y); ctx.stroke()
        const txt =
          (Math.abs(yv) < 1e-12) ? '0'
          : (Math.abs(yv) < 1 ? yv.toFixed(3)
          : (Math.abs(yv) < 10 ? yv.toFixed(2) : yv.toFixed(1)))
        ctx.fillText(txt, x0-7, y)
      }
    }

    function drawLine(ctx, xs, ys, xScale, yScale, colorVar='--recon', width=2) {
      if (!xs.length) return
      ctx.strokeStyle = getCSSVar(colorVar)
      ctx.lineWidth = width
      ctx.beginPath()
      for (let i=0;i<xs.length;i++){
        const x = xScale(xs[i])
        const y = yScale(ys[i])
        if (i===0) ctx.moveTo(x,y)
        else ctx.lineTo(x,y)
      }
      ctx.stroke()
    }

    function drawStems(ctx, xs, ys, xScale, yScale, baseY=0, colorVar='--recon') {
      const col = getCSSVar(colorVar)
      ctx.strokeStyle = col
      ctx.lineWidth = 1.5
      const y0 = yScale(baseY)
      for (let i=0;i<xs.length;i++){
        const x = xScale(xs[i])
        const y = yScale(ys[i])
        ctx.beginPath()
        ctx.moveTo(x, y0)
        ctx.lineTo(x, y)
        ctx.stroke()
      }
      ctx.fillStyle = col
      for (let i=0;i<xs.length;i++){
        const x = xScale(xs[i])
        const y = yScale(ys[i])
        ctx.beginPath()
        ctx.arc(x, y, 2.2, 0, 2*Math.PI)
        ctx.fill()
      }
    }

    function drawSpectralDiracs(ctx, freqs, amps, xScale, yScale, colorVar='--recon') {
      const col = getCSSVar(colorVar)
      ctx.strokeStyle = col
      ctx.lineWidth = 2
      const y0 = yScale(0)
      for (let i=0;i<freqs.length;i++){
        const x = xScale(freqs[i])
        const y = yScale(amps[i])
        ctx.beginPath()
        ctx.moveTo(x, y0)
        ctx.lineTo(x, y)
        ctx.stroke()
        ctx.fillStyle = col
        ctx.beginPath()
        ctx.arc(x, y, 3, 0, 2*Math.PI)
        ctx.fill()
      }
    }

    function drawPassband(ctx, xScale, yTop, yBot, fc, colorVar='--pass') {
      const col = getCSSVar(colorVar)
      const x1 = xScale(-fc)
      const x2 = xScale( fc)
      ctx.fillStyle = col
      ctx.globalAlpha = 0.18
      ctx.fillRect(Math.min(x1,x2), yTop, Math.abs(x2-x1), yBot-yTop)
      ctx.globalAlpha = 1.0
      ctx.strokeStyle = col
      ctx.lineWidth = 1.4
      ctx.strokeRect(Math.min(x1,x2), yTop, Math.abs(x2-x1), yBot-yTop)
    }

    // =====================
    // DSP helpers
    // =====================
    function wrapToNyquist(f, Fs) {
      // mapeia f para intervalo [-Fs/2, Fs/2)
      const half = Fs/2
      let x = ((f + half) % Fs + Fs) % Fs // [0, Fs)
      return x - half // [-Fs/2, Fs/2)
    }

    // =====================
    // UI components
    // =====================
    function Panel({title, right, children}) {
      return (
        <div className="panel">
          <div className="panelHead">
            <div className="panelTitle">{title}</div>
            <div className="panelRight">{right}</div>
          </div>
          {children}
        </div>
      )
    }

    function Pill({children, strong, warn}) {
      return <span className={warn ? "pill pillWarn" : (strong ? "pill pillStrong" : "pill")}>{children}</span>
    }

    function Btn({variant="primary", onClick, disabled, children}) {
      return (
        <button className={`btn ${variant}`} onClick={onClick} disabled={disabled}>
          {children}
        </button>
      )
    }

    function Toggle({label, checked, onChange, disabled}) {
      return (
        <div className="toggle" style={disabled ? {opacity:.55, cursor:'not-allowed'} : null}>
          <span>{label}</span>
          <input type="checkbox" checked={checked} disabled={disabled} onChange={e=>onChange(e.target.checked)} />
        </div>
      )
    }

    function Modal({open, title, onClose, children}) {
      if (!open) return null
      return (
        <div className="modalOverlay" role="dialog" aria-modal="true">
          <div className="modal">
            <div className="modalHead">
              <div className="modalTitle">{title}</div>
              <button className="iconBtn" onClick={onClose} aria-label="Fechar">✕</button>
            </div>
            <div className="modalBody">{children}</div>
          </div>
        </div>
      )
    }

    function Tooltip({state}) {
      if (!state?.show) return null
      const { x, y, text } = state
      return <div className="tip" style={{left:x, top:y}}>{text}</div>
    }

    // =====================
    // App
    // =====================
    function App() {
      const [theme, setTheme] = useState('light')
      useEffect(() => {
        document.documentElement.setAttribute('data-theme', theme)
      }, [theme])

      // Três cossenoides fixas (amplitude 1.0 cada quando ligadas)
      const [on480, setOn480]   = useState(true)
      const [on720, setOn720]   = useState(false)
      const [on1200, setOn1200] = useState(false)

      const enabled = useMemo(() => ([
        on480  ? 480  : null,
        on720  ? 720  : null,
        on1200 ? 1200 : null,
      ].filter(v=>v!=null)), [on480, on720, on1200])

      // amostragem
      const [discrete, setDiscrete] = useState(true)
      const [fs, setFs] = useState(4000) // 200..12000
      const fc = useMemo(() => fs/2, [fs])

      // janela visual (tempo) — curta para ver altas frequências
      const Tview = 0.010 // 10 ms
      const Ncont = 1200
      const pad = { l: 64, r: 18, t: 18, b: 44 }

      const [tipTime, setTipTime] = useState({show:false})
      const [tipSpec, setTipSpec] = useState({show:false})

      // modal
      const [showFiltered, setShowFiltered] = useState(false)
      const [showOrigInModal, setShowOrigInModal] = useState(true)
      const [showReconInModal, setShowReconInModal] = useState(true)

      // =====================
      // ÁUDIO (Web Audio)
      // - Reconstruído: amostra em Fs -> LPF ideal fc=Fs/2 -> reamostra em 44100
      //   Para soma de cossenos, isso equivale a usar f_alias = wrapToNyquist(f, Fs)
      // =====================
      const audioRef = useRef({ ctx:null, source:null, gain:null, playing:false })
      const [isPlaying, setIsPlaying] = useState(false)

      const stopAudio = useCallback(() => {
        const st = audioRef.current
        try { if (st?.source) st.source.stop(0) } catch {}
        if (st) {
          st.source = null
          st.playing = false
        }
        setIsPlaying(false)
      }, [])

      // se mudar parâmetros e estiver tocando, para
      useEffect(() => {
        if (isPlaying) stopAudio()
      }, [isPlaying, stopAudio, fs, discrete, on480, on720, on1200, showFiltered, showOrigInModal, showReconInModal])

      const playAudio = useCallback(async () => {
        try {
          // sinal correspondente:
          // - se modal aberto + recon marcado -> toca reconstruído
          // - senão -> toca original
          const wantRecon = showFiltered && showReconInModal

          const fOrig = enabled.slice()
          if (fOrig.length === 0) return

          // reconstrução ideal (conceito) => frequências em baseband
          const fRecon = fOrig.map(f => wrapToNyquist(f, fs)) // pode ser negativo

          // "repassar" para 44100 Hz (gera o sinal reconstruído e amostra em 44100)
          const freqsForAudio = wantRecon ? fRecon : fOrig

          // CRÍTICO: criar/retomar AudioContext dentro do clique
          let ctx = audioRef.current.ctx
          if (!ctx || ctx.state === 'closed') {
            ctx = new (window.AudioContext || window.webkitAudioContext)()
            audioRef.current.ctx = ctx
          }
          if (ctx.state === 'suspended') await ctx.resume()

          // Gain explícito
          let gain = audioRef.current.gain
          if (!gain) {
            gain = ctx.createGain()
            gain.gain.value = 0.9
            gain.connect(ctx.destination)
            audioRef.current.gain = gain
          }

          const sr = 44100
          const dur = 5.0
          const N = Math.floor(sr * dur)

          const buf = ctx.createBuffer(1, N, sr)
          const ch0 = buf.getChannelData(0)

          // normalização simples
          const nTones = freqsForAudio.length
          const scale = 0.9 / Math.max(1, nTones)

          for (let i=0;i<N;i++){
            const t = i / sr
            let y = 0
            for (let k=0;k<freqsForAudio.length;k++){
              const f = freqsForAudio[k]
              y += Math.cos(2*Math.PI*f*t) // f negativo ok
            }
            ch0[i] = scale * y
          }

          // tocar
          stopAudio()
          const src = ctx.createBufferSource()
          src.buffer = buf
          src.connect(gain)
          src.onended = () => {
            audioRef.current.source = null
            audioRef.current.playing = false
            setIsPlaying(false)
          }
          audioRef.current.source = src
          audioRef.current.playing = true
          setIsPlaying(true)
          src.start(0)
        } catch (err) {
          console.warn('Erro ao tocar áudio:', err)
          stopAudio()
          alert('Não foi possível tocar o áudio. Veja o console (F12) para detalhes.')
        }
      }, [enabled, fs, showFiltered, showReconInModal, stopAudio])

      // =====================
      // Sinal: soma de cossenos
      // =====================
      const synthValue = useCallback((t, freqs, amp=1.0) => {
        let y = 0
        for (let i=0;i<freqs.length;i++){
          const f = freqs[i]
          y += amp * Math.cos(2*Math.PI*f*t)
        }
        return y
      }, [])

      // tempo (contínuo + amostras)
      const timeData = useMemo(() => {
        // contínuo
        const x = new Float64Array(Ncont)
        const y = new Float64Array(Ncont)
        for (let i=0;i<Ncont;i++){
          const t = (i/(Ncont-1))*Tview
          x[i]=t
          y[i]=synthValue(t, enabled, 1.0)
        }

        // amostras
        const FsEff = Math.max(200, Math.min(12000, fs))
        const Ns = Math.max(2, Math.floor(Tview*FsEff) + 1)
        const xs = new Float64Array(Ns)
        const ys = new Float64Array(Ns)
        for (let n=0;n<Ns;n++){
          const t = n/FsEff
          xs[n] = t
          ys[n] = synthValue(t, enabled, 1.0)
        }

        return { x, y, xs, ys }
      }, [fs, enabled, synthValue])

      // range Y (tempo)
      const timeYRange = useMemo(() => {
        let ymin = +Infinity, ymax = -Infinity
        for (let i=0;i<timeData.y.length;i++){
          const v = timeData.y[i]
          if (v<ymin) ymin=v
          if (v>ymax) ymax=v
        }
        for (let i=0;i<timeData.ys.length;i++){
          const v = timeData.ys[i]
          if (v<ymin) ymin=v
          if (v>ymax) ymax=v
        }
        if (!Number.isFinite(ymin) || !Number.isFinite(ymax)) { ymin=-1; ymax=1 }
        const span = Math.max(1e-6, ymax-ymin)
        const padY = 0.18*span
        return { yMin: ymin-padY, yMax: ymax+padY }
      }, [timeData])

      // =====================
      // Espectro (visual): diracs + réplicas
      // =====================
      const SPEC_MIN = -6000
      const SPEC_MAX =  6000

      const spec = useMemo(() => {
        const baseAmp = 0.5
        const yMax = Math.max(1, enabled.length) * baseAmp * 1.25

        if (!discrete) {
          const freqs = []
          const amps  = []
          for (const f of enabled) {
            freqs.push(-f, +f)
            amps.push(baseAmp, baseAmp)
          }
          return { fMin: -1500, fMax: 1500, yMax, freqs, amps }
        }

        const spanGen = Math.max(2.2*fs, 6000)
        const fMinG = -spanGen
        const fMaxG =  spanGen

        const freqs = []
        const amps  = []

        for (const f0 of enabled) {
          const kMin = Math.floor((fMinG - f0) / fs) - 1
          const kMax = Math.ceil((fMaxG + f0) / fs) + 1
          for (let k=kMin; k<=kMax; k++){
            freqs.push(k*fs - f0, k*fs + f0)
            amps.push(baseAmp, baseAmp)
          }
        }

        // dedup
        const seen = new Set()
        const uf = []
        const ua = []
        for (let i=0;i<freqs.length;i++){
          const key = Math.round(freqs[i]*1e6)
          if (!seen.has(key)) {
            seen.add(key)
            uf.push(freqs[i])
            ua.push(amps[i])
          }
        }

        const fMin = SPEC_MIN
        const fMax = SPEC_MAX

        // filtra janela
        const wf = []
        const wa = []
        for (let i=0;i<uf.length;i++){
          if (uf[i] >= fMin && uf[i] <= fMax) {
            wf.push(uf[i])
            wa.push(ua[i])
          }
        }

        return { fMin, fMax, yMax, freqs: wf, amps: wa }
      }, [enabled, discrete, fs])

      // =====================
      // Reconstrução (tempo) via alias em baseband (LP ideal fc=Fs/2)
      // =====================
      const reconTime = useMemo(() => {
        const aliased = enabled.map(f => wrapToNyquist(f, fs)) // [-Fs/2, Fs/2)
        const x = new Float64Array(Ncont)
        const y = new Float64Array(Ncont)

        let ymin = +Infinity, ymax = -Infinity
        for (let i=0;i<Ncont;i++){
          const t = (i/(Ncont-1))*Tview
          x[i] = t
          const v = synthValue(t, aliased, 1.0)
          y[i] = v
          if (v<ymin) ymin=v
          if (v>ymax) ymax=v
        }
        if (!Number.isFinite(ymin) || !Number.isFinite(ymax)) { ymin=-1; ymax=1 }
        const span = Math.max(1e-6, ymax-ymin)
        const padY = 0.18*span
        return { x, y, yMin: ymin-padY, yMax: ymax+padY, aliased }
      }, [enabled, fs, synthValue])

      const modalYRange = useMemo(() => {
        let ymin = +Infinity, ymax = -Infinity
        if (showOrigInModal) {
          for (let i=0;i<timeData.y.length;i++){
            const v = timeData.y[i]
            if (v<ymin) ymin=v
            if (v>ymax) ymax=v
          }
        }
        if (showReconInModal) {
          for (let i=0;i<reconTime.y.length;i++){
            const v = reconTime.y[i]
            if (v<ymin) ymin=v
            if (v>ymax) ymax=v
          }
        }
        if (!Number.isFinite(ymin) || !Number.isFinite(ymax)) { ymin=-1; ymax=1 }
        const span = Math.max(1e-6, ymax-ymin)
        const padY = 0.18*span
        return { yMin: ymin-padY, yMax: ymax+padY }
      }, [showOrigInModal, showReconInModal, timeData, reconTime])

      // =====================
      // Draw time
      // =====================
      const timeWrapRef = useRef(null)
      const timeCanvasRef = useRef(null)

      const drawTime = useCallback(() => {
        const canvas = timeCanvasRef.current
        if (!canvas) return
        const { ctx, W, H } = fitCanvas(canvas)

        const yMin = timeYRange.yMin
        const yMax = timeYRange.yMax

        drawGrid(ctx, W, H, pad, 6, 6)
        drawNumericAxes(ctx, W, H, pad, 0, Tview, yMin, yMax, 6, 7)

        const { xScale, yScale } = makeScales(W, H, pad, 0, Tview, yMin, yMax)
        drawAxesLabels(ctx, W, H, pad, 'Tempo (s)', 'Amplitude')

        ctx.strokeStyle = getCSSVar('--gridH')
        ctx.lineWidth = 1
        ctx.beginPath()
        ctx.moveTo(pad.l, yScale(0))
        ctx.lineTo(W-pad.r, yScale(0))
        ctx.stroke()

        if (!discrete) {
          drawLine(ctx, timeData.x, timeData.y, xScale, yScale, '--recon', 2.2)
        } else {
          drawLine(ctx, timeData.x, timeData.y, xScale, yScale, '--orig', 1.2)
          drawStems(ctx, timeData.xs, timeData.ys, xScale, yScale, 0, '--recon')
        }

        ctx.fillStyle = getCSSVar('--inkDim')
        ctx.font = '12px system-ui, sans-serif'
        ctx.textAlign = 'left'
        ctx.fillText(discrete ? 'Tempo: contínuo + amostras' : 'Tempo: sinal contínuo', pad.l, 14)
      }, [timeData, discrete, timeYRange, fs, enabled, theme])

      useCanvas(timeCanvasRef, drawTime)

      // =====================
      // Draw spectrum
      // =====================
      const specWrapRef = useRef(null)
      const specCanvasRef = useRef(null)

      const drawSpec = useCallback(() => {
        const canvas = specCanvasRef.current
        if (!canvas) return
        const { ctx, W, H } = fitCanvas(canvas)

        drawGrid(ctx, W, H, pad, 9, 6)
        drawNumericAxes(ctx, W, H, pad, spec.fMin, spec.fMax, 0, spec.yMax, 9, 6)

        const { xScale, yScale } = makeScales(W, H, pad, spec.fMin, spec.fMax, 0, spec.yMax)
        drawAxesLabels(ctx, W, H, pad, 'Frequência (Hz)', 'Magnitude (visual)')

        if (discrete) {
          const yTop = pad.t
          const yBot = H - pad.b
          drawPassband(ctx, xScale, yTop, yBot, fc, '--pass')

          ctx.strokeStyle = getCSSVar('--passLine')
          ctx.lineWidth = 1.6
          const x1 = xScale(-fc), x2 = xScale(fc)
          ctx.beginPath(); ctx.moveTo(x1, pad.t); ctx.lineTo(x1, H-pad.b); ctx.stroke()
          ctx.beginPath(); ctx.moveTo(x2, pad.t); ctx.lineTo(x2, H-pad.b); ctx.stroke()
        }

        ctx.strokeStyle = getCSSVar('--gridV')
        ctx.lineWidth = 1
        ctx.beginPath()
        ctx.moveTo(xScale(0), pad.t)
        ctx.lineTo(xScale(0), H-pad.b)
        ctx.stroke()

        drawSpectralDiracs(ctx, spec.freqs, spec.amps, xScale, yScale, '--recon')

        ctx.fillStyle = getCSSVar('--inkDim')
        ctx.font = '12px system-ui, sans-serif'
        ctx.textAlign = 'left'
        const lbl = !discrete
          ? 'Espectro (contínuo): deltas em ±fi'
          : `Espectro (amostrado): réplicas em k·Fs ± fi | reconstrução: LP ideal fc=Fs/2=${fc.toFixed(0)} Hz`
        ctx.fillText(lbl, pad.l, 14)
      }, [spec, discrete, fc, theme])

      useCanvas(specCanvasRef, drawSpec)

      // =====================
      // Modal draw: original + reconstruído
      // =====================
      const reconCanvasRef = useRef(null)

      const drawRecon = useCallback(() => {
        const canvas = reconCanvasRef.current
        if (!canvas) return
        const { ctx, W, H } = fitCanvas(canvas)

        const yMin = modalYRange.yMin
        const yMax = modalYRange.yMax

        drawGrid(ctx, W, H, pad, 6, 6)
        drawNumericAxes(ctx, W, H, pad, 0, Tview, yMin, yMax, 6, 7)

        const { xScale, yScale } = makeScales(W, H, pad, 0, Tview, yMin, yMax)
        drawAxesLabels(ctx, W, H, pad, 'Tempo (s)', 'Amplitude')

        if (showOrigInModal) drawLine(ctx, timeData.x, timeData.y, xScale, yScale, '--orig', 2.0)
        if (showReconInModal) drawLine(ctx, reconTime.x, reconTime.y, xScale, yScale, '--recon', 2.2)

        ctx.fillStyle = getCSSVar('--inkDim')
        ctx.font = '12px system-ui, sans-serif'
        ctx.textAlign = 'left'
        const ali = discrete ? reconTime.aliased.map(f=>f.toFixed(2)).join(', ') : '—'
        ctx.fillText(`Original + Reconstrução (fc=Fs/2) | f_alias (Hz): ${ali}`, pad.l, 14)
      }, [reconTime, timeData, modalYRange, showOrigInModal, showReconInModal, theme, discrete])

      useEffect(() => { if (showFiltered) drawRecon() }, [showFiltered, drawRecon])
      useCanvas(reconCanvasRef, drawRecon)

      // =====================
      // Tooltips
      // =====================
      const onTimeMove = useCallback((e) => {
        const wrap = timeWrapRef.current
        const canvas = timeCanvasRef.current
        if (!wrap || !canvas) return

        const rect = canvas.getBoundingClientRect()
        const px = e.clientX - rect.left
        const py = e.clientY - rect.top
        const W = rect.width, H = rect.height

        const { xInv } = makeScales(W, H, pad, 0, Tview, timeYRange.yMin, timeYRange.yMax)
        if (px < pad.l || px > (W - pad.r) || py < pad.t || py > (H - pad.b)) {
          setTipTime({show:false})
          return
        }

        const t = xInv(px)
        const y = synthValue(t, enabled, 1.0)

        let extra = ''
        if (discrete) {
          const n = Math.round(t * fs)
          const ts = n / fs
          const ys = synthValue(ts, enabled, 1.0)
          extra = ` | amostra: t=${ts.toFixed(6)} s, y=${ys.toFixed(4)}`
        }

        const wrapRect = wrap.getBoundingClientRect()
        setTipTime({
          show:true,
          x: e.clientX - wrapRect.left + 12,
          y: e.clientY - wrapRect.top + 12,
          text: `t=${t.toFixed(6)} s, y=${y.toFixed(4)}${extra}`
        })
      }, [fs, discrete, enabled, synthValue, Tview, timeYRange])

      const onSpecMove = useCallback((e) => {
        const wrap = specWrapRef.current
        const canvas = specCanvasRef.current
        if (!wrap || !canvas) return

        const rect = canvas.getBoundingClientRect()
        const px = e.clientX - rect.left
        const py = e.clientY - rect.top
        const W = rect.width, H = rect.height

        const { xScale } = makeScales(W, H, pad, spec.fMin, spec.fMax, 0, spec.yMax)
        if (px < pad.l || px > (W - pad.r) || py < pad.t || py > (H - pad.b)) {
          setTipSpec({show:false})
          return
        }

        let bestF = null, bestDx = Infinity
        for (let i=0;i<spec.freqs.length;i++){
          const xi = xScale(spec.freqs[i])
          const dx = Math.abs(xi - px)
          if (dx < bestDx) { bestDx = dx; bestF = spec.freqs[i] }
        }
        if (bestF == null || bestDx > 10) {
          setTipSpec({show:false})
          return
        }

        const wrapRect = wrap.getBoundingClientRect()
        setTipSpec({
          show:true,
          x: e.clientX - wrapRect.left + 12,
          y: e.clientY - wrapRect.top + 12,
          text: `f=${bestF.toFixed(3)} Hz | fc=Fs/2=${fc.toFixed(0)} Hz`
        })
      }, [spec, fc])

      const aliasRisk = useMemo(() => {
        if (!discrete) return false
        const half = fs/2
        return enabled.some(f => f > half)
      }, [discrete, fs, enabled])

      const enabledStr = enabled.length ? enabled.join(', ') : 'nenhuma'

      return (
        <div className="wrap">
          <style>{`
            :root{
              --bg:#f6f7fb; --panel:#ffffff; --panel2:#f1f3f8; --ink:#0f172a; --inkDim:#475569;
              --border:#d8dee9; --input:#ffffff; --inputBorder:#cbd5e1;
              --canvas:#ffffff; --gridV:#d1d5db; --gridH:#e5e7eb; --frame:#94a3b8;

              --orig:#64748b; --recon:#2563eb; --danger:#dc2626; --accent:#2563eb;
              --pass:#22c55e; --passLine:#16a34a;
            }
            :root[data-theme="dark"]{
              --bg:#0f1420; --panel:#151b2a; --panel2:#121828; --ink:#e8eefc; --inkDim:#a8b2c8;
              --border:#1b2235; --input:#0e1424; --inputBorder:#2a3859;
              --canvas:#0d1322; --gridV:#2a334a; --gridH:#1f293b; --frame:#223252;

              --orig:#94a3b8; --recon:#9ad5ff; --danger:#ff3b3b; --accent:#3b82f6;
              --pass:#34d399; --passLine:#10b981;
            }

            *{ box-sizing:border-box; }
            body{ margin:0; background:var(--bg); color:var(--ink);
              font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto; }

            .wrap{ max-width:1100px; margin:0 auto; padding:18px 14px 40px; }
            .topbar{ display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:12px; }
            h1{ margin:0; font-size:18px; font-weight:700; letter-spacing:.2px; }
            .subtitle{ margin:6px 0 0; font-size:13px; color:var(--inkDim); }

            .panel{ background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:12px;
              box-shadow:0 6px 18px rgba(0,0,0,.10); }
            .panelHead{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px; }
            .panelTitle{ font-weight:650; font-size:14px; color:var(--ink); }
            .panelRight{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:flex-end; }

            .grid{ display:grid; grid-template-columns: 1fr 380px; gap:12px; }
            @media(max-width: 980px){ .grid{ grid-template-columns:1fr; } }

            .control{ background:var(--panel2); border:1px solid var(--border); border-radius:10px; padding:10px; margin-bottom:10px; }
            .ctlLabel{ display:block; font-size:13px; color:var(--inkDim); margin-bottom:8px; }
            .ctlBody{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
            input[type=range]{ width:100%; accent-color: var(--accent); }

            input[type=number], select{ width:160px; background:var(--input); color:var(--ink);
              border:1px solid var(--inputBorder); border-radius:8px; padding:6px 8px; font-size:14px; }

            .pill{ display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px;
              border:1px solid var(--border); background:var(--panel2); color:var(--inkDim); font-size:13px; white-space:nowrap; }
            .pillStrong{ border:1px solid var(--accent); color:var(--ink); box-shadow:0 6px 18px rgba(37,99,235,.10); }
            .pillWarn{ border:1px solid var(--danger); color:var(--ink); box-shadow:0 6px 18px rgba(220,38,38,.10); }

            .btn{ border:1px solid var(--border); background:var(--panel2); color:var(--ink);
              padding:8px 10px; border-radius:10px; cursor:pointer; font-size:13px; }
            .btn.primary{ border-color: var(--accent); box-shadow:0 6px 18px rgba(37,99,235,.10); }
            .btn.danger{ border-color: var(--danger); }

            .toggle{ display:flex; align-items:center; justify-content:space-between;
              background:var(--panel2); border:1px solid var(--border); border-radius:10px;
              padding:8px 10px; color:var(--inkDim); font-size:13px; gap:10px; width:100%; }
            .toggle input{ transform: scale(1.15); }

            canvas.main{ width:100%; height:260px; display:block; background:var(--canvas);
              border-radius:12px; border:1px solid var(--border); }

            .note{ font-size:12px; color:var(--inkDim); line-height:1.35; margin:0 0 6px; }
            .hr{ height:1px; background:var(--border); margin:10px 0; opacity:.8; }
            .plotWrap{ position:relative; }

            .tip{ position:absolute; pointer-events:none; max-width:520px; padding:8px 10px; border-radius:10px;
              border:1px solid var(--border); background:var(--panel); color:var(--ink); font-size:12px;
              box-shadow:0 10px 26px rgba(0,0,0,.22); white-space:nowrap; z-index:5; }

            .modalOverlay{ position:fixed; inset:0; background:rgba(0,0,0,.45);
              display:flex; align-items:center; justify-content:center; padding:16px; z-index:1000; }
            .modal{ width:min(920px, 96vw); background:var(--panel); border:1px solid var(--border);
              border-radius:12px; box-shadow:0 20px 60px rgba(0,0,0,.35); overflow:hidden; }
            .modalHead{ display:flex; align-items:center; justify-content:space-between;
              padding:12px 12px 8px; border-bottom:1px solid var(--border); }
            .modalTitle{ font-weight:650; font-size:14px; }
            .iconBtn{ border:1px solid var(--border); background:var(--panel2); color:var(--ink);
              border-radius:10px; width:36px; height:32px; cursor:pointer; }
            .modalBody{ padding:12px; }
          `}</style>

          <div className="topbar">
            <div>
              <h1>Amostragem no domínio da frequência — 3 cossenoides</h1>
              <div className="subtitle">
                Sinal original = soma das cossenoides ligadas (480, 720, 1200 Hz).
                Reconstrução sempre via LP ideal com <b>fc = Fs/2</b>. Áudio: 5 s em 44100 Hz.
              </div>
            </div>

            <div style={{display:'flex', gap:10, alignItems:'center'}}>
              <select value={theme} onChange={e=>setTheme(e.target.value)}>
                <option value="light">Light</option>
                <option value="dark">Dark</option>
              </select>
            </div>
          </div>

          <div className="grid">
            <Panel
              title="Visualização"
              right={
                <>
                  <Pill strong>tons (Hz): <b>{enabledStr}</b></Pill>
                  <Pill strong>Fs: <b>{fs.toFixed(0)}</b> Hz</Pill>
                  <Pill>Nyquist: <b>{(fs/2).toFixed(0)}</b> Hz</Pill>
                  <Pill strong>fc: <b>{(fs/2).toFixed(0)}</b> Hz</Pill>
                  {aliasRisk && <Pill warn>⚠ aliasing (algum tom &gt; Fs/2)</Pill>}
                </>
              }
            >
              <div style={{display:'grid', gap:12}}>
                <div className="plotWrap" ref={timeWrapRef}>
                  <div className="note"><b>Tempo</b> — {discrete ? 'contínuo + amostras' : 'contínuo'} (janela: {(Tview*1000).toFixed(1)} ms)</div>
                  <canvas
                    className="main"
                    ref={timeCanvasRef}
                    onMouseMove={onTimeMove}
                    onMouseLeave={()=>setTipTime({show:false})}
                  />
                  <Tooltip state={tipTime} />
                </div>

                <div className="plotWrap" ref={specWrapRef}>
                  <div className="note">
                    <b>Frequência</b> — {discrete ? 'réplicas (k·Fs ± fi)' : 'deltas em ±fi'}
                    {discrete ? ` | passband (reconstrução): |f|≤fc=Fs/2=${fc.toFixed(0)} Hz` : ''} 
                  </div>
                  <canvas
                    className="main"
                    ref={specCanvasRef}
                    onMouseMove={onSpecMove}
                    onMouseLeave={()=>setTipSpec({show:false})}
                  />
                  <Tooltip state={tipSpec} />
                </div>
              </div>
            </Panel>

            <Panel title="Controles">
              <div className="control">
                <div className="ctlLabel">Cossenoides no sinal original</div>
                <div className="ctlBody" style={{alignItems:'stretch'}}>
                  <Toggle label="cos 480 Hz" checked={on480} onChange={setOn480} />
                  <Toggle label="cos 720 Hz" checked={on720} onChange={setOn720} />
                  <Toggle label="cos 1200 Hz" checked={on1200} onChange={setOn1200} />
                </div>
                <div className="note" style={{marginTop:8}}>
                  Cada componente ligada tem amplitude 1.0. O áudio normaliza automaticamente para evitar clipping.
                </div>
              </div>

              <div className="control">
                <div className="ctlLabel">Amostragem</div>
                <div className="ctlBody">
                  <Toggle label="Discretizar (amostrar)" checked={discrete} onChange={(v)=>{
                    setDiscrete(v)
                    if (!v) setShowFiltered(false)
                  }} />

                  <div style={{flex:'1 1 180px', minWidth:240}}>
                    <div className="note" style={{margin:'0 0 6px'}}>Fs (Hz) — 200 a 12000</div>
                    <input
                      type="range" min="200" max="12000" step="10"
                      value={fs}
                      disabled={!discrete}
                      onChange={e=>setFs(Number(e.target.value))}
                    />
                  </div>

                  <input
                    type="number" min="200" max="12000" step="10"
                    value={fs}
                    disabled={!discrete}
                    onChange={e=>setFs(Number(e.target.value))}
                  />
                </div>

                <div className="hr"></div>

                <div className="ctlBody" style={{justifyContent:'space-between'}}>
                  <Btn
                    variant="primary"
                    disabled={!discrete}
                    onClick={()=>{ if(discrete) setShowFiltered(true) }}
                  >
                    Ver sinal reconstruído
                  </Btn>

                  <Btn
                    variant={isPlaying ? "danger" : "primary"}
                    disabled={enabled.length===0}
                    onClick={()=>{ isPlaying ? stopAudio() : playAudio() }}
                  >
                    {isPlaying ? "Parar áudio" : "Reproduzir áudio (5s)"}
                  </Btn>
                </div>

                <div className="note" style={{marginTop:8}}>
                  O botão de áudio toca o sinal “correspondente”: se o modal estiver aberto com “Reconstruído” marcado,
                  toca a reconstrução (após LP ideal fc=Fs/2 e reamostragem em 44100). Caso contrário, toca o original.
                </div>
              </div>
            </Panel>
          </div>

          <Modal
            open={showFiltered}
            title="Sinal no tempo: original vs reconstruído (LP ideal fc=Fs/2)"
            onClose={()=>setShowFiltered(false)}
          >
            <div style={{display:'flex', gap:10, flexWrap:'wrap', marginBottom:10}}>
              <Toggle label="Original" checked={showOrigInModal} onChange={setShowOrigInModal} />
              <Toggle label="Reconstruído (LP ideal)" checked={showReconInModal} onChange={setShowReconInModal} />
            </div>

            <div className="note" style={{marginBottom:10}}>
              Reconstrução modelada como soma das frequências em baseband:
              <b> f_alias = wrapToNyquist(fi, Fs) ∈ [-Fs/2, Fs/2)</b>, com <b>fc=Fs/2</b>.
            </div>

            <canvas className="main" ref={reconCanvasRef} />
          </Modal>
        </div>
      )
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App/>)
  </script>
</body>
</html>
