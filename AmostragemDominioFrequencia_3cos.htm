<!doctype html>
<html lang="pt-BR" data-theme="light">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Amostragem no domínio da Frequência</title>

  <script>
    (function () {
      document.documentElement.setAttribute('data-theme', 'light');
    })();
  </script>
</head>
<body>
  <div id="root"></div>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState, useCallback } = React

    // =====================
    // Canvas helpers
    // =====================
    function useCanvas(ref, draw) {
      useEffect(() => {
        const onResize = () => draw()
        window.addEventListener('resize', onResize)
        draw()
        return () => window.removeEventListener('resize', onResize)
      }, [draw])
    }

    function fitCanvas(canvas) {
      const dpr = window.devicePixelRatio || 1
      const cw = canvas.clientWidth || 800
      const ch = canvas.clientHeight || 320
      canvas.width  = Math.round(cw * dpr)
      canvas.height = Math.round(ch * dpr)
      const ctx = canvas.getContext('2d')
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0)
      return { ctx, W: cw, H: ch }
    }

    function getCSSVar(name) {
      return getComputedStyle(document.documentElement).getPropertyValue(name).trim()
    }

    function drawGrid(ctx, W, H, pad, xTicks=6, yTicks=6) {
      const bg = getCSSVar('--canvas')
      const gridV = getCSSVar('--gridV')
      const gridH = getCSSVar('--gridH')
      const frame = getCSSVar('--frame')

      ctx.fillStyle = bg
      ctx.fillRect(0,0,W,H)

      ctx.strokeStyle = gridV
      ctx.lineWidth = 1
      for (let i=0;i<xTicks;i++){
        const x = pad.l + (W-pad.l-pad.r)*(i/(xTicks-1))
        ctx.beginPath(); ctx.moveTo(x,pad.t); ctx.lineTo(x,H-pad.b); ctx.stroke()
      }

      ctx.strokeStyle = gridH
      ctx.lineWidth = 1
      for (let i=0;i<yTicks;i++){
        const y = pad.t + (H-pad.t-pad.b)*(i/(yTicks-1))
        ctx.beginPath(); ctx.moveTo(pad.l,y); ctx.lineTo(W-pad.r,y); ctx.stroke()
      }

      ctx.strokeStyle = frame
      ctx.strokeRect(pad.l, pad.t, W-pad.l-pad.r, H-pad.t-pad.b)
    }

    function makeScales(W, H, pad, xMin, xMax, yMin, yMax) {
      const xScale = x => pad.l + (W-pad.l-pad.r) * ((x - xMin) / (xMax - xMin || 1))
      const yScale = y => {
        const p = (y - yMin) / (yMax - yMin || 1)
        return H - pad.b - p*(H-pad.t-pad.b)
      }
      const xInv = px => xMin + ((px - pad.l) / (W-pad.l-pad.r)) * (xMax-xMin)
      return { xScale, yScale, xInv }
    }

    function drawAxesLabels(ctx, W, H, pad, xLabel, yLabel) {
      const inkDim = getCSSVar('--inkDim')
      ctx.fillStyle = inkDim
      ctx.font = '12px system-ui, sans-serif'

      ctx.textAlign = 'right'
      ctx.fillText(xLabel, W-8, H-10)

      ctx.save()
      ctx.translate(14, pad.t + (H-pad.t-pad.b)/2)
      ctx.rotate(-Math.PI/2)
      ctx.textAlign = 'center'
      ctx.fillText(yLabel, 0, 0)
      ctx.restore()
    }

    function drawNumericAxes(ctx, W, H, pad, xMin, xMax, yMin, yMax, xTicks=6, yTicks=6) {
      const inkDim = getCSSVar('--inkDim')
      const frame = getCSSVar('--frame')
      ctx.font = '12px system-ui, sans-serif'
      ctx.fillStyle = inkDim
      ctx.strokeStyle = frame
      ctx.lineWidth = 1

      const { xScale, yScale } = makeScales(W, H, pad, xMin, xMax, yMin, yMax)

      // X ticks
      ctx.textAlign = 'center'
      ctx.textBaseline = 'top'
      for (let i=0;i<xTicks;i++){
        const t = i/(xTicks-1)
        const xv = xMin + t*(xMax-xMin)
        const x = xScale(xv)
        const y0 = H - pad.b
        ctx.beginPath(); ctx.moveTo(x, y0); ctx.lineTo(x, y0+5); ctx.stroke()
        const txt =
          (Math.abs(xv) < 1e-12) ? '0' :
          (Math.abs(xv) < 1 ? xv.toFixed(4) :
          (Math.abs(xv) < 10 ? xv.toFixed(3) :
          (Math.abs(xv) < 100 ? xv.toFixed(2) : xv.toFixed(0))))
        ctx.fillText(txt, x, y0+7)
      }

      // Y ticks
      ctx.textAlign = 'right'
      ctx.textBaseline = 'middle'
      for (let i=0;i<yTicks;i++){
        const t = i/(yTicks-1)
        const yv = yMin + (1-t)*(yMax-yMin)
        const y = yScale(yv)
        const x0 = pad.l
        ctx.beginPath(); ctx.moveTo(x0-5, y); ctx.lineTo(x0, y); ctx.stroke()
        const txt =
          (Math.abs(yv) < 1e-12) ? '0' :
          (Math.abs(yv) < 1 ? yv.toFixed(3) :
          (Math.abs(yv) < 10 ? yv.toFixed(2) : yv.toFixed(1)))
        ctx.fillText(txt, x0-7, y)
      }
    }

    function drawLine(ctx, xs, ys, xScale, yScale, colorVar='--recon', width=2) {
      if (!xs.length) return
      ctx.strokeStyle = getCSSVar(colorVar)
      ctx.lineWidth = width
      ctx.beginPath()
      for (let i=0;i<xs.length;i++){
        const x = xScale(xs[i])
        const y = yScale(ys[i])
        if (i===0) ctx.moveTo(x,y)
        else ctx.lineTo(x,y)
      }
      ctx.stroke()
    }

    function drawStems(ctx, xs, ys, xScale, yScale, baseY=0, colorVar='--recon') {
      const col = getCSSVar(colorVar)
      ctx.strokeStyle = col
      ctx.lineWidth = 1.5
      const y0 = yScale(baseY)
      for (let i=0;i<xs.length;i++){
        const x = xScale(xs[i])
        const y = yScale(ys[i])
        ctx.beginPath()
        ctx.moveTo(x, y0)
        ctx.lineTo(x, y)
        ctx.stroke()
      }
      ctx.fillStyle = col
      for (let i=0;i<xs.length;i++){
        const x = xScale(xs[i])
        const y = yScale(ys[i])
        ctx.beginPath()
        ctx.arc(x, y, 2.2, 0, 2*Math.PI)
        ctx.fill()
      }
    }

    function drawSpectralDiracs(ctx, freqs, amps, xScale, yScale, colorVar='--recon') {
      const col = getCSSVar(colorVar)
      ctx.strokeStyle = col
      ctx.lineWidth = 2
      const y0 = yScale(0)
      for (let i=0;i<freqs.length;i++){
        const x = xScale(freqs[i])
        const y = yScale(amps[i])
        ctx.beginPath()
        ctx.moveTo(x, y0)
        ctx.lineTo(x, y)
        ctx.stroke()
        ctx.fillStyle = col
        ctx.beginPath()
        ctx.arc(x, y, 3, 0, 2*Math.PI)
        ctx.fill()
      }
    }

    function drawPassband(ctx, xScale, yTop, yBot, fc, colorVar='--pass') {
      const col = getCSSVar(colorVar)
      const x1 = xScale(-fc)
      const x2 = xScale( fc)
      ctx.fillStyle = col
      ctx.globalAlpha = 0.18
      ctx.fillRect(Math.min(x1,x2), yTop, Math.abs(x2-x1), yBot-yTop)
      ctx.globalAlpha = 1.0
      ctx.strokeStyle = col
      ctx.lineWidth = 1.4
      ctx.strokeRect(Math.min(x1,x2), yTop, Math.abs(x2-x1), yBot-yTop)
    }

    // =====================
    // DSP helper
    // =====================
    function wrapToNyquist(f, Fs) {
      const half = Fs/2
      let x = ((f + half) % Fs + Fs) % Fs // [0, Fs)
      return x - half // [-Fs/2, Fs/2)
    }

    // =====================
    // WAV helpers (PCM16)
    // =====================
    function floatToPCM16(x) {
      const v = Math.max(-1, Math.min(1, x))
      return v < 0 ? Math.round(v * 32768) : Math.round(v * 32767)
    }

    function writeString(view, offset, str) {
      for (let i=0;i<str.length;i++) view.setUint8(offset+i, str.charCodeAt(i))
    }

    function makeWavBlobFromMonoFloat32(samplesFloat32, sampleRate) {
      const numChannels = 1
      const bitsPerSample = 16
      const blockAlign = numChannels * bitsPerSample/8
      const byteRate = sampleRate * blockAlign
      const dataSize = samplesFloat32.length * blockAlign
      const buffer = new ArrayBuffer(44 + dataSize)
      const view = new DataView(buffer)

      writeString(view, 0, 'RIFF')
      view.setUint32(4, 36 + dataSize, true)
      writeString(view, 8, 'WAVE')

      writeString(view, 12, 'fmt ')
      view.setUint32(16, 16, true)
      view.setUint16(20, 1, true) // PCM
      view.setUint16(22, numChannels, true)
      view.setUint32(24, sampleRate, true)
      view.setUint32(28, byteRate, true)
      view.setUint16(32, blockAlign, true)
      view.setUint16(34, bitsPerSample, true)

      writeString(view, 36, 'data')
      view.setUint32(40, dataSize, true)

      let off = 44
      for (let i=0;i<samplesFloat32.length;i++){
        view.setInt16(off, floatToPCM16(samplesFloat32[i]), true)
        off += 2
      }

      return new Blob([buffer], { type: 'audio/wav' })
    }

    // =====================
    // UI components
    // =====================
    function Panel({title, right, children}) {
      return (
        <div className="panel">
          <div className="panelHead">
            <div className="panelTitle">{title}</div>
            <div className="panelRight">{right}</div>
          </div>
          {children}
        </div>
      )
    }

    function Pill({children, strong, warn}) {
      return <span className={warn ? "pill pillWarn" : (strong ? "pill pillStrong" : "pill")}>{children}</span>
    }

    function Btn({variant="primary", onClick, disabled, children}) {
      return (
        <button className={`btn ${variant}`} onClick={onClick} disabled={disabled}>
          {children}
        </button>
      )
    }

    function Toggle({label, checked, onChange, disabled}) {
      return (
        <div className="toggle" style={disabled ? {opacity:.55, cursor:'not-allowed'} : null}>
          <span>{label}</span>
          <input type="checkbox" checked={checked} disabled={disabled} onChange={e=>onChange(e.target.checked)} />
        </div>
      )
    }

    function Modal({open, title, onClose, children}) {
      if (!open) return null
      return (
        <div className="modalOverlay" role="dialog" aria-modal="true">
          <div className="modal">
            <div className="modalHead">
              <div className="modalTitle">{title}</div>
              <button className="iconBtn" onClick={onClose} aria-label="Fechar">✕</button>
            </div>
            <div className="modalBody">{children}</div>
          </div>
        </div>
      )
    }

    function Tooltip({state}) {
      if (!state?.show) return null
      const { x, y, text } = state
      return <div className="tip" style={{left:x, top:y}}>{text}</div>
    }

    // =====================
    // App
    // =====================
    function App() {
      const [theme, setTheme] = useState('light')
      useEffect(() => {
        document.documentElement.setAttribute('data-theme', theme)
      }, [theme])

      // Frequências pedidas
      const F1 = 500, F2 = 1300, F3 = 2100

      const [on500, setOn500] = useState(true)
      const [on1300, setOn1300] = useState(true)
      const [on2100, setOn2100] = useState(true)

      const enabled = useMemo(() => ([
        on500 ? F1 : null,
        on1300 ? F2 : null,
        on2100 ? F3 : null,
      ].filter(v=>v!=null)), [on500, on1300, on2100])

      // discretização SEMPRE ativa
      const [fs, setFs] = useState(2400) // 200..12000
      const fc = useMemo(() => fs/2, [fs])

      // visualização no tempo
      const Tview = 0.010 // 10 ms
      const Ncont = 1200
      const pad = { l: 64, r: 18, t: 18, b: 44 }

      const [tipTime, setTipTime] = useState({show:false})
      const [tipSpec, setTipSpec] = useState({show:false})

      // modal
      const [showFiltered, setShowFiltered] = useState(false)
      const [showOrigInModal, setShowOrigInModal] = useState(true)
      const [showReconInModal, setShowReconInModal] = useState(true)

      // =====================
      // ÁUDIO via <audio> — SEMPRE do sinal RECONSTRUÍDO (alias/baseband)
      // =====================
      const audioElRef = useRef(null)
      const audioUrlRef = useRef(null)
      const [isPlaying, setIsPlaying] = useState(false)

      const stopAudio = useCallback(() => {
        const el = audioElRef.current
        if (el) {
          el.pause()
          el.currentTime = 0
        }
        setIsPlaying(false)
      }, [])

      useEffect(() => {
        const el = audioElRef.current
        if (!el) return

        const onEnded = () => {
          setIsPlaying(false)
          if (audioUrlRef.current) {
            URL.revokeObjectURL(audioUrlRef.current)
            audioUrlRef.current = null
          }
        }
        el.addEventListener('ended', onEnded)
        return () => el.removeEventListener('ended', onEnded)
      }, [])

      // se mudar parâmetros enquanto toca, para e limpa URL
      useEffect(() => {
        if (isPlaying) stopAudio()
        if (audioUrlRef.current) {
          URL.revokeObjectURL(audioUrlRef.current)
          audioUrlRef.current = null
        }
      }, [fs, on500, on1300, on2100])

      function synthCosSum(t, freqs) {
        let y = 0
        for (let i=0;i<freqs.length;i++){
          y += Math.cos(2*Math.PI*freqs[i]*t)
        }
        return y
      }

      const playAudio = useCallback(async () => {
        const el = audioElRef.current
        if (!el) return

        const fOrig = enabled.slice()
        if (fOrig.length === 0) return

        const fAlias = fOrig.map(f => wrapToNyquist(f, fs))

        const sr = 44100
        const dur = 5.0
        const N = Math.floor(sr * dur)

        const scale = 0.90 / Math.max(1, fAlias.length)

        const samples = new Float32Array(N)
        for (let i=0;i<N;i++){
          const t = i / sr
          samples[i] = scale * synthCosSum(t, fAlias)
        }

        if (audioUrlRef.current) {
          URL.revokeObjectURL(audioUrlRef.current)
          audioUrlRef.current = null
        }

        const wavBlob = makeWavBlobFromMonoFloat32(samples, sr)
        const url = URL.createObjectURL(wavBlob)
        audioUrlRef.current = url

        el.src = url
        el.currentTime = 0

        try {
          await el.play()
          setIsPlaying(true)
        } catch (err) {
          console.warn('HTMLAudio play() bloqueado:', err)
          alert('O navegador bloqueou a reprodução. Tente clicar novamente ou verifique se a aba/site não está mutado.')
          setIsPlaying(false)
        }
      }, [enabled, fs])

      // =====================
      // Tempo: contínuo + amostras
      // =====================
      const timeData = useMemo(() => {
        const x = new Float64Array(Ncont)
        const y = new Float64Array(Ncont)
        for (let i=0;i<Ncont;i++){
          const t = (i/(Ncont-1))*Tview
          x[i]=t
          y[i]=synthCosSum(t, enabled)
        }

        const FsEff = Math.max(200, Math.min(12000, fs))
        const Ns = Math.max(2, Math.floor(Tview*FsEff) + 1)
        const xs = new Float64Array(Ns)
        const ys = new Float64Array(Ns)
        for (let n=0;n<Ns;n++){
          const t = n/FsEff
          xs[n] = t
          ys[n] = synthCosSum(t, enabled)
        }
        return { x, y, xs, ys }
      }, [fs, enabled])

      const timeYRange = useMemo(() => {
        let ymin = +Infinity, ymax = -Infinity
        for (let i=0;i<timeData.y.length;i++){
          const v = timeData.y[i]
          if (v<ymin) ymin=v
          if (v>ymax) ymax=v
        }
        for (let i=0;i<timeData.ys.length;i++){
          const v = timeData.ys[i]
          if (v<ymin) ymin=v
          if (v>ymax) ymax=v
        }
        if (!Number.isFinite(ymin) || !Number.isFinite(ymax)) { ymin=-1; ymax=1 }
        const span = Math.max(1e-6, ymax-ymin)
        const padY = 0.18*span
        return { yMin: ymin-padY, yMax: ymax+padY }
      }, [timeData])

      // =====================
      // Espectro (visual) — eixo FIXO: [-2500, 2500]
      // =====================
      const SPEC_MIN = -2500
      const SPEC_MAX =  2500

      const spec = useMemo(() => {
        const baseAmp = 0.5
        const yMax = Math.max(1, enabled.length) * baseAmp * 1.25

        const freqs = []
        const amps  = []

        // Gerar réplicas suficientes para cobrir exatamente o eixo fixo
        const fMinG = SPEC_MIN
        const fMaxG = SPEC_MAX

        for (const f0 of enabled) {
          const kMin = Math.floor((fMinG - f0) / fs) - 1
          const kMax = Math.ceil((fMaxG + f0) / fs) + 1
          for (let k=kMin; k<=kMax; k++){
            freqs.push(k*fs - f0, k*fs + f0)
            amps.push(baseAmp, baseAmp)
          }
        }

        // dedup por frequência
        const seen = new Set()
        const uf = []
        const ua = []
        for (let i=0;i<freqs.length;i++){
          const key = Math.round(freqs[i]*1e6)
          if (!seen.has(key)) {
            seen.add(key)
            uf.push(freqs[i])
            ua.push(amps[i])
          }
        }

        // recorta pela janela fixa
        const wf = []
        const wa = []
        for (let i=0;i<uf.length;i++){
          if (uf[i] >= SPEC_MIN && uf[i] <= SPEC_MAX) {
            wf.push(uf[i])
            wa.push(ua[i])
          }
        }

        return { fMin: SPEC_MIN, fMax: SPEC_MAX, yMax, freqs: wf, amps: wa }
      }, [enabled, fs])

      // =====================
      // Reconstrução (tempo)
      // =====================
      const reconTime = useMemo(() => {
        const aliased = enabled.map(f => wrapToNyquist(f, fs))
        const x = new Float64Array(Ncont)
        const y = new Float64Array(Ncont)

        let ymin = +Infinity, ymax = -Infinity
        for (let i=0;i<Ncont;i++){
          const t = (i/(Ncont-1))*Tview
          x[i] = t
          const v = synthCosSum(t, aliased)
          y[i] = v
          if (v<ymin) ymin=v
          if (v>ymax) ymax=v
        }
        if (!Number.isFinite(ymin) || !Number.isFinite(ymax)) { ymin=-1; ymax=1 }
        const span = Math.max(1e-6, ymax-ymin)
        const padY = 0.18*span
        return { x, y, yMin: ymin-padY, yMax: ymax+padY, aliased }
      }, [enabled, fs])

      const modalYRange = useMemo(() => {
        let ymin = +Infinity, ymax = -Infinity
        if (showOrigInModal) {
          for (let i=0;i<timeData.y.length;i++){
            const v = timeData.y[i]
            if (v<ymin) ymin=v
            if (v>ymax) ymax=v
          }
        }
        if (showReconInModal) {
          for (let i=0;i<reconTime.y.length;i++){
            const v = reconTime.y[i]
            if (v<ymin) ymin=v
            if (v>ymax) ymax=v
          }
        }
        if (!Number.isFinite(ymin) || !Number.isFinite(ymax)) { ymin=-1; ymax=1 }
        const span = Math.max(1e-6, ymax-ymin)
        const padY = 0.18*span
        return { yMin: ymin-padY, yMax: ymax+padY }
      }, [showOrigInModal, showReconInModal, timeData, reconTime])

      // =====================
      // Draw time
      // =====================
      const timeWrapRef = useRef(null)
      const timeCanvasRef = useRef(null)

      const drawTime = useCallback(() => {
        const canvas = timeCanvasRef.current
        if (!canvas) return
        const { ctx, W, H } = fitCanvas(canvas)

        const yMin = timeYRange.yMin
        const yMax = timeYRange.yMax

        drawGrid(ctx, W, H, pad, 6, 6)
        drawNumericAxes(ctx, W, H, pad, 0, Tview, yMin, yMax, 6, 7)

        const { xScale, yScale } = makeScales(W, H, pad, 0, Tview, yMin, yMax)
        drawAxesLabels(ctx, W, H, pad, 'Tempo (s)', 'Amplitude')

        ctx.strokeStyle = getCSSVar('--gridH')
        ctx.lineWidth = 1
        ctx.beginPath()
        ctx.moveTo(pad.l, yScale(0))
        ctx.lineTo(W-pad.r, yScale(0))
        ctx.stroke()

        drawLine(ctx, timeData.x, timeData.y, xScale, yScale, '--orig', 1.2)
        drawStems(ctx, timeData.xs, timeData.ys, xScale, yScale, 0, '--recon')

        ctx.fillStyle = getCSSVar('--inkDim')
        ctx.font = '12px system-ui, sans-serif'
        ctx.textAlign = 'left'
        ctx.fillText('Tempo', pad.l, 14)
      }, [timeData, timeYRange, fs, enabled, theme])

      useCanvas(timeCanvasRef, drawTime)

      // =====================
      // Draw spectrum (eixo fixo)
      // =====================
      const specWrapRef = useRef(null)
      const specCanvasRef = useRef(null)

      const drawSpec = useCallback(() => {
        const canvas = specCanvasRef.current
        if (!canvas) return
        const { ctx, W, H } = fitCanvas(canvas)

        drawGrid(ctx, W, H, pad, 9, 6)
        drawNumericAxes(ctx, W, H, pad, spec.fMin, spec.fMax, 0, spec.yMax, 9, 6)

        const { xScale, yScale } = makeScales(W, H, pad, spec.fMin, spec.fMax, 0, spec.yMax)
        drawAxesLabels(ctx, W, H, pad, 'Frequência (Hz)', 'Magnitude (visual)')

        const yTop = pad.t
        const yBot = H - pad.b
        drawPassband(ctx, xScale, yTop, yBot, fc, '--pass')

        ctx.strokeStyle = getCSSVar('--passLine')
        ctx.lineWidth = 1.6
        const x1 = xScale(-fc), x2 = xScale(fc)
        ctx.beginPath(); ctx.moveTo(x1, pad.t); ctx.lineTo(x1, H-pad.b); ctx.stroke()
        ctx.beginPath(); ctx.moveTo(x2, pad.t); ctx.lineTo(x2, H-pad.b); ctx.stroke()

        ctx.strokeStyle = getCSSVar('--gridV')
        ctx.lineWidth = 1
        ctx.beginPath()
        ctx.moveTo(xScale(0), pad.t)
        ctx.lineTo(xScale(0), H-pad.b)
        ctx.stroke()

        drawSpectralDiracs(ctx, spec.freqs, spec.amps, xScale, yScale, '--recon')

        ctx.fillStyle = getCSSVar('--inkDim')
        ctx.font = '12px system-ui, sans-serif'
        ctx.textAlign = 'left'
        ctx.fillText(`Frequência`, pad.l, 14)
      }, [spec, fc, theme])

      useCanvas(specCanvasRef, drawSpec)

      // =====================
      // Modal draw
      // =====================
      const reconCanvasRef = useRef(null)

      const drawRecon = useCallback(() => {
        const canvas = reconCanvasRef.current
        if (!canvas) return
        const { ctx, W, H } = fitCanvas(canvas)

        const yMin = modalYRange.yMin
        const yMax = modalYRange.yMax

        drawGrid(ctx, W, H, pad, 6, 6)
        drawNumericAxes(ctx, W, H, pad, 0, Tview, yMin, yMax, 6, 7)

        const { xScale, yScale } = makeScales(W, H, pad, 0, Tview, yMin, yMax)
        drawAxesLabels(ctx, W, H, pad, 'Tempo (s)', 'Amplitude')

        if (showOrigInModal) drawLine(ctx, timeData.x, timeData.y, xScale, yScale, '--orig', 2.0)
        if (showReconInModal) drawLine(ctx, reconTime.x, reconTime.y, xScale, yScale, '--recon', 2.2)

        ctx.fillStyle = getCSSVar('--inkDim')
        ctx.font = '12px system-ui, sans-serif'
        ctx.textAlign = 'left'
        const ali = reconTime.aliased.map(f=>f.toFixed(2)).join(', ')
        ctx.fillText(`Original + Reconstrução`, pad.l, 14)
      }, [reconTime, timeData, modalYRange, showOrigInModal, showReconInModal, theme])

      useEffect(() => { if (showFiltered) drawRecon() }, [showFiltered, drawRecon])
      useCanvas(reconCanvasRef, drawRecon)

      // =====================
      // Tooltips
      // =====================
      const onTimeMove = useCallback((e) => {
        const wrap = timeWrapRef.current
        const canvas = timeCanvasRef.current
        if (!wrap || !canvas) return

        const rect = canvas.getBoundingClientRect()
        const px = e.clientX - rect.left
        const py = e.clientY - rect.top
        const W = rect.width, H = rect.height

        const { xInv } = makeScales(W, H, pad, 0, Tview, timeYRange.yMin, timeYRange.yMax)
        if (px < pad.l || px > (W - pad.r) || py < pad.t || py > (H - pad.b)) {
          setTipTime({show:false})
          return
        }

        const t = xInv(px)
        const y = synthCosSum(t, enabled)

        const n = Math.round(t * fs)
        const ts = n / fs
        const ys = synthCosSum(ts, enabled)

        const wrapRect = wrap.getBoundingClientRect()
        setTipTime({
          show:true,
          x: e.clientX - wrapRect.left + 12,
          y: e.clientY - wrapRect.top + 12,
          text: `t=${t.toFixed(6)} s, y(cont)=${y.toFixed(4)} | amostra: t=${ts.toFixed(6)} s, y=${ys.toFixed(4)}`
        })
      }, [fs, enabled, Tview, timeYRange])

      const onSpecMove = useCallback((e) => {
        const wrap = specWrapRef.current
        const canvas = specCanvasRef.current
        if (!wrap || !canvas) return

        const rect = canvas.getBoundingClientRect()
        const px = e.clientX - rect.left
        const py = e.clientY - rect.top
        const W = rect.width, H = rect.height

        const { xScale } = makeScales(W, H, pad, spec.fMin, spec.fMax, 0, spec.yMax)
        if (px < pad.l || px > (W - pad.r) || py < pad.t || py > (H - pad.b)) {
          setTipSpec({show:false})
          return
        }

        let bestF = null, bestDx = Infinity
        for (let i=0;i<spec.freqs.length;i++){
          const xi = xScale(spec.freqs[i])
          const dx = Math.abs(xi - px)
          if (dx < bestDx) { bestDx = dx; bestF = spec.freqs[i] }
        }
        if (bestF == null || bestDx > 10) {
          setTipSpec({show:false})
          return
        }

        const wrapRect = wrap.getBoundingClientRect()
        setTipSpec({
          show:true,
          x: e.clientX - wrapRect.left + 12,
          y: e.clientY - wrapRect.top + 12,
          text: `f=${bestF.toFixed(3)} Hz | fc=Fs/2=${fc.toFixed(0)} Hz`
        })
      }, [spec, fc])

      const aliasRisk = useMemo(() => {
        const half = fs/2
        return enabled.some(f => f > half)
      }, [fs, enabled])

      const enabledStr = enabled.length ? enabled.join(', ') : 'nenhuma'

      const aliasStr = useMemo(() => {
        const ali = enabled.map(f => wrapToNyquist(f, fs))
        return ali.map(v => v.toFixed(2)).join(', ')
      }, [enabled, fs])

      return (
        <div className="wrap">
          <style>{`
            :root{
              --bg:#f6f7fb; --panel:#ffffff; --panel2:#f1f3f8; --ink:#0f172a; --inkDim:#475569;
              --border:#d8dee9; --input:#ffffff; --inputBorder:#cbd5e1;
              --canvas:#ffffff; --gridV:#d1d5db; --gridH:#e5e7eb; --frame:#94a3b8;

              --orig:#64748b; --recon:#2563eb; --danger:#dc2626; --accent:#2563eb;
              --pass:#22c55e; --passLine:#16a34a;
            }
            :root[data-theme="dark"]{
              --bg:#0f1420; --panel:#151b2a; --panel2:#121828; --ink:#e8eefc; --inkDim:#a8b2c8;
              --border:#1b2235; --input:#0e1424; --inputBorder:#2a3859;
              --canvas:#0d1322; --gridV:#2a334a; --gridH:#1f293b; --frame:#223252;

              --orig:#94a3b8; --recon:#9ad5ff; --danger:#ff3b3b; --accent:#3b82f6;
              --pass:#34d399; --passLine:#10b981;
            }

            *{ box-sizing:border-box; }
            body{ margin:0; background:var(--bg); color:var(--ink);
              font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto; }

            .wrap{ max-width:1100px; margin:0 auto; padding:18px 14px 40px; }
            .topbar{ display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:12px; }
            h1{ margin:0; font-size:18px; font-weight:700; letter-spacing:.2px; }
            .subtitle{ margin:6px 0 0; font-size:13px; color:var(--inkDim); }

            .panel{ background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:12px;
              box-shadow:0 6px 18px rgba(0,0,0,.10); }
            .panelHead{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px; }
            .panelTitle{ font-weight:650; font-size:14px; color:var(--ink); }
            .panelRight{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:flex-end; }

            .grid{ display:grid; grid-template-columns: 1fr 380px; gap:12px; }
            @media(max-width: 980px){ .grid{ grid-template-columns:1fr; } }

            .control{ background:var(--panel2); border:1px solid var(--border); border-radius:10px; padding:10px; margin-bottom:10px; }
            .ctlLabel{ display:block; font-size:13px; color:var(--inkDim); margin-bottom:8px; }
            .ctlBody{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
            input[type=range]{ width:100%; accent-color: var(--accent); }

            input[type=number], select{ width:160px; background:var(--input); color:var(--ink);
              border:1px solid var(--inputBorder); border-radius:8px; padding:6px 8px; font-size:14px; }

            .pill{ display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px;
              border:1px solid var(--border); background:var(--panel2); color:var(--inkDim); font-size:13px; white-space:nowrap; }
            .pillStrong{ border:1px solid var(--accent); color:var(--ink); box-shadow:0 6px 18px rgba(37,99,235,.10); }
            .pillWarn{ border:1px solid var(--danger); color:var(--ink); box-shadow:0 6px 18px rgba(220,38,38,.10); }

            .btn{ border:1px solid var(--border); background:var(--panel2); color:var(--ink);
              padding:8px 10px; border-radius:10px; cursor:pointer; font-size:13px; }
            .btn.primary{ border-color: var(--accent); box-shadow:0 6px 18px rgba(37,99,235,.10); }
            .btn.danger{ border-color: var(--danger); }

            .toggle{ display:flex; align-items:center; justify-content:space-between;
              background:var(--panel2); border:1px solid var(--border); border-radius:10px;
              padding:8px 10px; color:var(--inkDim); font-size:13px; gap:10px; width:100%; }
            .toggle input{ transform: scale(1.15); }

            canvas.main{ width:100%; height:260px; display:block; background:var(--canvas);
              border-radius:12px; border:1px solid var(--border); }

            .note{ font-size:12px; color:var(--inkDim); line-height:1.35; margin:0 0 6px; }
            .hr{ height:1px; background:var(--border); margin:10px 0; opacity:.8; }
            .plotWrap{ position:relative; }

            .tip{ position:absolute; pointer-events:none; max-width:520px; padding:8px 10px; border-radius:10px;
              border:1px solid var(--border); background:var(--panel); color:var(--ink); font-size:12px;
              box-shadow:0 10px 26px rgba(0,0,0,.22); white-space:nowrap; z-index:5; }

            .modalOverlay{ position:fixed; inset:0; background:rgba(0,0,0,.45);
              display:flex; align-items:center; justify-content:center; padding:16px; z-index:1000; }
            .modal{ width:min(920px, 96vw); background:var(--panel); border:1px solid var(--border);
              border-radius:12px; box-shadow:0 20px 60px rgba(0,0,0,.35); overflow:hidden; }
            .modalHead{ display:flex; align-items:center; justify-content:space-between;
              padding:12px 12px 8px; border-bottom:1px solid var(--border); }
            .modalTitle{ font-weight:650; font-size:14px; }
            .iconBtn{ border:1px solid var(--border); background:var(--panel2); color:var(--ink);
              border-radius:10px; width:36px; height:32px; cursor:pointer; }
            .modalBody{ padding:12px; }
          `}</style>

          <div className="topbar">
            <div>
              <h1>Amostragem no domínio da frequência</h1>
            </div>

            <div style={{display:'flex', gap:10, alignItems:'center'}}>
              <select value={theme} onChange={e=>setTheme(e.target.value)}>
                <option value="light">Light</option>
                <option value="dark">Dark</option>
              </select>
            </div>
          </div>

          <div className="grid">
            <Panel
              title="Visualização"
              right={
                <>
                  <Pill strong>tons (Hz): <b>{enabledStr}</b></Pill>
                  <Pill strong>Fs: <b>{fs.toFixed(0)}</b> Hz</Pill>
                  <Pill>Nyquist: <b>{(fs/2).toFixed(0)}</b> Hz</Pill>
                  {aliasRisk && <Pill warn>⚠ aliasing</Pill>}
                </>
              }
            >
              <div style={{display:'grid', gap:12}}>
                <div className="plotWrap" ref={timeWrapRef}>
                  <div className="note"><b>Tempo</b> — contínuo + amostras (janela: {(Tview*1000).toFixed(1)} ms)</div>
                  <canvas
                    className="main"
                    ref={timeCanvasRef}
                    onMouseMove={onTimeMove}
                    onMouseLeave={()=>setTipTime({show:false})}
                  />
                  <Tooltip state={tipTime} />
                </div>

                <div className="plotWrap" ref={specWrapRef}>
                  <canvas
                    className="main"
                    ref={specCanvasRef}
                    onMouseMove={onSpecMove}
                    onMouseLeave={()=>setTipSpec({show:false})}
                  />
                  <Tooltip state={tipSpec} />
                </div>
              </div>
            </Panel>

            <Panel title="Controles">
              <div className="control">
                <div className="ctlLabel">Sinal</div>
                <div className="ctlBody" style={{alignItems:'stretch'}}>
                  <Toggle label="500 Hz" checked={on500} onChange={setOn500} />
                  <Toggle label="1300 Hz" checked={on1300} onChange={setOn1300} />
                  <Toggle label="2100 Hz" checked={on2100} onChange={setOn2100} />
                </div>
              </div>

              <div className="control">
                <div className="ctlLabel">Frequência de amostragem</div>
                <div className="ctlBody">
                  <div style={{flex:'1 1 180px', minWidth:240}}>
                    <div className="note" style={{margin:'0 0 6px'}}>Fs (Hz) — 200 a 12000</div>
                    <input
                      type="range" min="200" max="12000" step="10"
                      value={fs}
                      onChange={e=>setFs(Number(e.target.value))}
                    />
                  </div>

                  <input
                    type="number" min="200" max="12000" step="10"
                    value={fs}
                    onChange={e=>setFs(Number(e.target.value))}
                  />
                </div>

                <div className="hr"></div>

                <div className="ctlBody" style={{justifyContent:'space-between'}}>
                  <Btn
                    variant="primary"
                    onClick={()=> setShowFiltered(true)}
                  >
                    Ver sinal reconstruído
                  </Btn>

                  <Btn
                    variant={isPlaying ? "danger" : "primary"}
                    disabled={enabled.length===0}
                    onClick={()=>{ isPlaying ? stopAudio() : playAudio() }}
                  >
                    {isPlaying ? "Parar áudio" : "Reproduzir áudio reconstruído (5s)"}
                  </Btn>
                </div>
                <audio ref={audioElRef} style={{width:'100%', marginTop:10}} controls />
              </div>
            </Panel>
          </div>

          <Modal
            open={showFiltered}
            title="Sinal no tempo: original vs reconstruído (LP ideal fc=Fs/2)"
            onClose={()=>setShowFiltered(false)}
          >
            <div style={{display:'flex', gap:10, flexWrap:'wrap', marginBottom:10}}>
              <Toggle label="Original" checked={showOrigInModal} onChange={setShowOrigInModal} />
              <Toggle label="Reconstruído (LP ideal)" checked={showReconInModal} onChange={setShowReconInModal} />
            </div>
            <canvas className="main" ref={reconCanvasRef} />
          </Modal>
        </div>
      )
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App/>)
  </script>
</body>
</html>
