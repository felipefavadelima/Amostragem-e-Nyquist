<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <title>Amostragem e Nyquist — JSX no browser</title>
    <!-- React 18 UMD -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel Standalone para transpilar JSX no navegador -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
  </head>
  <body style="margin:0;background:#0f1420;color:#e8eefc">
    <div id="root"></div>

    <script type="text/babel">
      // Seu código, apenas sem import e sem export default

      const { useEffect, useMemo, useRef, useState } = React

      const TWO_PI = Math.PI * 2

      function sincNorm(x) {
        if (x === 0) return 1
        return Math.sin(Math.PI * x) / (Math.PI * x)
      }

      function blackmanCont(u) {
        if (Math.abs(u) > 1) return 0
        return 0.42 + 0.5 * Math.cos(Math.PI * u) + 0.08 * Math.cos(2 * Math.PI * u)
      }

      // Malha de tempo densa de 0 a T
      function linspaceN(n, T) {
        const out = new Float64Array(n)
        const dt = T / (n - 1)
        for (let i = 0; i < n; i++) out[i] = i * dt
        return out
      }

      function analogSignal(t, f, phaseRad) {
        return Math.sin(TWO_PI * f * t + phaseRad)
      }

      function sampleTimes(Fs, T) {
        if (Fs <= 0) return []
        const N = Math.floor(T * Fs) + 1
        const Ts = 1 / Fs
        const times = new Float64Array(N)
        for (let i = 0; i < N; i++) times[i] = i * Ts
        return times
      }

      function linearInterp(tGrid, tS, yS) {
        if (!yS || yS.length === 0) return new Float64Array(tGrid.length)
        if (yS.length === 1) return new Float64Array(tGrid.length).fill(yS[0])
        const Ts = tS[1] - tS[0]
        const out = new Float64Array(tGrid.length)
        for (let k = 0; k < tGrid.length; k++) {
          const t = tGrid[k]
          let idx = Math.floor(t / Ts)
          if (idx < 0) idx = 0
          if (idx >= yS.length - 1) idx = yS.length - 2
          const t0 = tS[idx]
          const t1 = tS[idx + 1]
          const y0 = yS[idx]
          const y1 = yS[idx + 1]
          const w = (t - t0) / (t1 - t0)
          out[k] = y0 + w * (y1 - y0)
        }
        return out
      }

      function cubicSplineUniform(tGrid, tS, yS) {
        const n = yS.length
        if (n === 0) return new Float64Array(tGrid.length)
        if (n === 1) return new Float64Array(tGrid.length).fill(yS[0])
        if (n === 2) return linearInterp(tGrid, tS, yS)
        const Ts = tS[1] - tS[0]
        const m = new Float64Array(n)
        const a = new Float64Array(n)
        const b = new Float64Array(n)
        const c = new Float64Array(n)
        const d = new Float64Array(n)
        b[0] = 1
        d[0] = 0
        b[n - 1] = 1
        d[n - 1] = 0
        for (let i = 1; i <= n - 2; i++) {
          a[i] = 1
          b[i] = 4
          c[i] = 1
          d[i] = 6 * (yS[i + 1] - 2 * yS[i] + yS[i - 1]) / (Ts * Ts)
        }
        for (let i = 1; i < n; i++) {
          const w = a[i] / b[i - 1]
          b[i] = b[i] - w * c[i - 1]
          d[i] = d[i] - w * d[i - 1]
        }
        m[n - 1] = d[n - 1] / b[n - 1]
        for (let i = n - 2; i >= 0; i--) {
          m[i] = (d[i] - c[i] * m[i + 1]) / b[i]
        }
        const out = new Float64Array(tGrid.length)
        for (let k = 0; k < tGrid.length; k++) {
          const t = tGrid[k]
          if (t <= tS[0]) { out[k] = yS[0]; continue }
          if (t >= tS[n - 1]) { out[k] = yS[n - 1]; continue }
          const i = Math.floor((t - tS[0]) / Ts)
          const x0 = tS[i]
          const x1 = tS[i + 1]
          const h = Ts
          const A = (x1 - t) / h
          const B = (t - x0) / h
          const s = m[i] * Math.pow(x1 - t, 3) / (6 * h)
          const r = m[i + 1] * Math.pow(t - x0, 3) / (6 * h)
          const p = (yS[i] - m[i] * h * h / 6) * A
          const q = (yS[i + 1] - m[i + 1] * h * h / 6) * B
          out[k] = s + r + p + q
        }
        return out
      }

      // Passa baixas com correção de ganho Ts na convolução do trem de deltas
      function lpfRecon(tGrid, tS, yS, Fs) {
        const nS = yS.length
        const out = new Float64Array(tGrid.length)
        if (nS === 0) return out
        const Ts = 1 / Fs
        const fc = 0.45 * Fs
        const lobes = 10
        const Tlen = Math.min(lobes / Math.max(fc, 1e-9), 1.0)
        for (let k = 0; k < tGrid.length; k++) {
          const t = tGrid[k]
          let iMin = Math.ceil((t - Tlen) / Ts)
          let iMax = Math.floor((t + Tlen) / Ts)
          if (iMin < 0) iMin = 0
          if (iMax > nS - 1) iMax = nS - 1
          let acc = 0
          for (let i = iMin; i <= iMax; i++) {
            const tau = t - tS[i]
            const u = tau / Tlen
            const w = blackmanCont(u)
            const h = 2 * fc * sincNorm(2 * fc * tau)
            acc += yS[i] * h * w * Ts
          }
          out[k] = acc
        }
        return out
      }

      // Hook de desenho
      function useCanvasPlot(ref, drawer) {
        useEffect(() => {
          function onResize() { drawer() }
          window.addEventListener('resize', onResize)
          drawer()
          return () => window.removeEventListener('resize', onResize)
        }, [drawer])
      }

      // Drawer consulta o ref no momento do desenho e usa T dinâmico
      function makeDrawer(ref, data, opts) {
        const { T, tFine, yAnalog, tS, yS, yRecon, mode, showAnalog, showSamples, showRecon } = data
        const { colors } = opts
        return () => {
          const canvas = ref?.current
          const ctx = canvas?.getContext?.('2d')
          if (!canvas || !ctx) return

          const dpr = window.devicePixelRatio || 1
          const w = canvas.clientWidth || 600
          const h = canvas.clientHeight || 280
          canvas.width = Math.max(600, w * dpr)
          canvas.height = Math.max(240, h * dpr)
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0)

          const W = canvas.clientWidth || 600
          const H = canvas.clientHeight || 280
          const left = 48
          const right = 16
          const top = 16
          const bottom = 28

          function xScale(t) { return left + (W - left - right) * (t / T) }
          function yMap(y, lo, hi) { const p = (y - lo) / (hi - lo); return H - bottom - p * (H - top - bottom) }

          function minMax(arrs) {
            let lo = Infinity
            let hi = -Infinity
            arrs.forEach(a => {
              if (!a) return
              for (let i = 0; i < a.length; i++) {
                const v = a[i]
                if (v < lo) lo = v
                if (v > hi) hi = v
              }
            })
            if (!isFinite(lo) || !isFinite(hi)) { lo = -1; hi = 1 }
            if (Math.abs(hi - lo) < 1e-6) { lo -= 1; hi += 1 }
            const pad = 0.1 * (hi - lo)
            return [lo - pad, hi + pad]
          }

          const candidates = []
          if (showAnalog) candidates.push(yAnalog)
          if (showSamples) candidates.push(yS)
          if (showRecon && yRecon) candidates.push(yRecon)
          const [yMin, yMax] = minMax(candidates.length ? candidates : [new Float64Array([ -1, 1 ])])

          ctx.fillStyle = '#0d1322'
          ctx.fillRect(0, 0, W, H)

          ctx.strokeStyle = '#2a334a'
          const gridN = 5
          for (let i = 0; i < gridN; i++) {
            const tt = (T * i) / (gridN - 1)
            const x = xScale(tt)
            ctx.beginPath()
            ctx.moveTo(x, top)
            ctx.lineTo(x, H - bottom)
            ctx.stroke()
            ctx.fillStyle = '#89a'
            ctx.font = '12px sans-serif'
            ctx.textAlign = 'center'
            const prec = T < 1 ? 2 : 1
            ctx.fillText(tt.toFixed(prec), x, H - 8)
          }

          const ticks = 5
          for (let i = 0; i < ticks; i++) {
            const y = yMin + i * (yMax - yMin) / (ticks - 1)
            const py = yMap(y, yMin, yMax)
            ctx.strokeStyle = '#2a334a'
            ctx.beginPath()
            ctx.moveTo(left, py)
            ctx.lineTo(W - right, py)
            ctx.stroke()
            ctx.fillStyle = '#89a'
            ctx.textAlign = 'right'
            ctx.fillText(y.toFixed(2), left - 6, py + 4)
          }

          ctx.strokeStyle = '#223252'
          ctx.strokeRect(left, top, W - left - right, H - top - bottom)

          ctx.fillStyle = '#b7c2db'
          ctx.font = '12px sans-serif'
          ctx.save()
          ctx.translate(12, H / 2)
          ctx.rotate(-Math.PI / 2)
          ctx.textAlign = 'center'
          ctx.fillText('Amplitude', 0, 0)
          ctx.restore()
          ctx.textAlign = 'right'
          ctx.fillText('tempo em s', W - 10, H - 38)

          function polyline(tArr, yArr, color, width, dashed) {
            if (!tArr || tArr.length === 0) return
            ctx.save()
            ctx.beginPath()
            for (let k = 0; k < tArr.length; k++) {
              const x = xScale(tArr[k])
              const y = yMap(yArr[k], yMin, yMax)
              if (k === 0) ctx.moveTo(x, y)
              else ctx.lineTo(x, y)
            }
            ctx.lineWidth = width
            ctx.strokeStyle = color
            if (dashed) ctx.setLineDash([6, 6])
            ctx.stroke()
            ctx.setLineDash([])
            ctx.restore()
          }

          function scatter(tArr, yArr, color) {
            if (!tArr || tArr.length === 0) return
            ctx.save()
            ctx.fillStyle = color
            ctx.strokeStyle = '#ffd2d2'
            for (let i = 0; i < tArr.length; i++) {
              const x = xScale(tArr[i])
              const y = yMap(yArr[i], yMin, yMax)
              ctx.beginPath()
              ctx.arc(x, y, 4, 0, TWO_PI)
              ctx.fill()
              ctx.lineWidth = 1
              ctx.stroke()
            }
            ctx.restore()
          }

          if (showAnalog) polyline(tFine, yAnalog, '#bfc7d9', 2, false)
          if (showSamples && tS && tS.length) scatter(tS, yS, '#ff3b3b')
          if (showRecon && yRecon) {
            if (mode === 'linear') polyline(tFine, yRecon, '#2b84ff', 2, true)
            else if (mode === 'spline') polyline(tFine, yRecon, '#2b84ff', 2.5, false)
            else if (mode === 'lpf') polyline(tFine, yRecon, '#2b84ff', 3.5, false)
          }
        }
      }

      function App() {
        const [Fs, setFs] = useState(200)
        const [f, setF] = useState(50)
        const [phase, setPhase] = useState(0)
        const [mode, setMode] = useState('linear')
        const [T, setT] = useState(2)
        const [testMsg, setTestMsg] = useState('Rodando testes')

        // Visibilidade do único gráfico
        const [visBottom, setVisBottom] = useState({ analog: true, samples: true, recon: true })

        const plotRef = useRef(null)

        // resolução da curva analógica proporcional ao tamanho da janela
        const tFine = useMemo(() => {
          const ptsPerSec = 2000
          const n = Math.max(1001, Math.round(T * ptsPerSec) + 1)
          return linspaceN(n, T)
        }, [T])

        const phaseRad = useMemo(() => phase * Math.PI / 180, [phase])

        const yAnalog = useMemo(() => {
          const out = new Float64Array(tFine.length)
          for (let i = 0; i < tFine.length; i++) out[i] = analogSignal(tFine[i], f, phaseRad)
          return out
        }, [tFine, f, phaseRad])

        const tS = useMemo(() => sampleTimes(Fs, T), [Fs, T])
        const yS = useMemo(() => {
          if (!tS.length) return []
          const arr = new Float64Array(tS.length)
          for (let i = 0; i < tS.length; i++) arr[i] = analogSignal(tS[i], f, phaseRad)
          return arr
        }, [tS, f, phaseRad])

        const yLinear = useMemo(() => Fs > 0 ? linearInterp(tFine, tS, yS) : null, [Fs, tFine, tS, yS])
        const ySpline = useMemo(() => Fs > 0 ? cubicSplineUniform(tFine, tS, yS) : null, [Fs, tFine, tS, yS])
        const yLPF = useMemo(() => Fs > 0 ? lpfRecon(tFine, tS, yS, Fs) : null, [Fs, tFine, tS, yS])

        const yRecon = mode === 'linear' ? yLinear : mode === 'spline' ? ySpline : mode === 'lpf' ? yLPF : null

        const hasAlias = Fs > 0 && f > Fs / 2
        const fAlias = hasAlias ? Math.abs(f - Math.round(f / Fs) * Fs) : 0

        const colors = {
          analog: '#bfc7d9',
          recon: '#2b84ff',
          reconThick: '#2b84ff',
          point: '#ff3b3b'
        }

        const draw = useMemo(() => makeDrawer(
          plotRef,
          { T, tFine, yAnalog, tS, yS, yRecon, mode, showAnalog: visBottom.analog, showSamples: visBottom.samples, showRecon: visBottom.recon },
          { colors }
        ), [plotRef, T, tFine, yAnalog, tS, yS, yRecon, visBottom, mode])

        useCanvasPlot(plotRef, draw)

        function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)) }

        function resetAll() {
          setFs(200)
          setF(50)
          setPhase(0)
          setMode('linear')
          setT(2)
          setVisBottom({ analog: true, samples: true, recon: true })
        }

        // Testes automáticos simples
        useEffect(() => {
          try {
            const alias = Math.abs(60 - Math.round(60 / 80) * 80)
            console.assert(alias === 20, 'Teste aliasing falhou, esperado 20, obtido', alias)

            const TstFs = 200
            const TstF = 50
            const tFineT = linspaceN(2001, 2)
            const tST = sampleTimes(TstFs, 2)
            const yST = new Float64Array(tST.length)
            for (let i = 0; i < tST.length; i++) yST[i] = analogSignal(tST[i], TstF, 0)
            const yLinT = linearInterp(tFineT, tST, yST)
            const yAnaT = new Float64Array(tFineT.length)
            for (let i = 0; i < tFineT.length; i++) yAnaT[i] = analogSignal(tFineT[i], TstF, 0)
            let se = 0
            for (let i = 0; i < yAnaT.length; i++) { const e = yAnaT[i] - yLinT[i]; se += e * e }
            const rmse = Math.sqrt(se / yAnaT.length)
            console.assert(rmse < 0.2, 'Teste RMSE linear alto', rmse)

            // Ganho aproximado em passa baixas deve ser próximo de 1 para sinais bem abaixo do corte
            const tFineP = linspaceN(2001, 2)
            const FsP = 200
            const fP = 10
            const tSP = sampleTimes(FsP, 2)
            const ySP = new Float64Array(tSP.length)
            for (let i = 0; i < tSP.length; i++) ySP[i] = analogSignal(tSP[i], fP, 0)
            const yLPFP = lpfRecon(tFineP, tSP, ySP, FsP)
            const yAnaP = new Float64Array(tFineP.length)
            for (let i = 0; i < tFineP.length; i++) yAnaP[i] = analogSignal(tFineP[i], fP, 0)
            let seP = 0
            for (let i = 0; i < yAnaP.length; i++) { const e = yAnaP[i] - yLPFP[i]; seP += e * e }
            const rmseP = Math.sqrt(seP / yAnaP.length)
            console.assert(rmseP < 0.25, 'Ganho passa baixas fora do esperado', rmseP)

            setTestMsg('Testes passaram')
          } catch (e) {
            console.error('Falha nos testes', e)
            setTestMsg('Falha nos testes, ver console')
          }
        }, [])

        return (
          <div className="wrap">
            <style>{`
              :root { --bg:#0f1420; --panel:#151b2a; --ink:#e8eefc; --ink-dim:#a8b2c8; --grid:#2a334a }
              * { box-sizing: border-box }
              body { margin:0; background:var(--bg); color:var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell }
              .wrap { max-width:1100px; margin:0 auto; padding:18px 14px 40px }
              h1 { margin:4px 0 14px; font-size:20px; font-weight:700; letter-spacing:.2px; text-align:center }
              .panel { background:var(--panel); border:1px solid #1b2235; border-radius:10px; padding:12px; box-shadow:0 6px 18px rgba(0,0,0,.25) }
              .controls { display:grid; grid-template-columns:repeat(12,1fr); gap:10px 12px; align-items:center }
              .control { grid-column:span 3; display:grid; grid-template-columns:1fr auto; gap:8px; align-items:center; background:#121828; border:1px solid #1b2235; border-radius:10px; padding:10px }
              .control label { grid-column:1 / -1; font-size:13px; color:var(--ink-dim) }
              input[type=range] { width:100%; accent-color:#4da3ff }
              input[type=number] { width:90px; background:#0e1424; color:#e8eefc; border:1px solid #2a3859; border-radius:8px; padding:6px 8px; font-size:14px }
              .row { margin-top:12px }
              .radios { display:flex; flex-wrap:wrap; gap:10px 16px; align-items:center; padding:12px; border-radius:10px; background:#121828; border:1px solid #1b2235 }
              .radios label { display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:8px; background:#0e1424; border:1px solid #2a3859; font-size:14px; cursor:pointer }
              .meta { display:flex; flex-wrap:wrap; gap:10px 16px; align-items:center; padding:10px 12px; color:var(--ink-dim); font-size:14px }
              .pill { background:#10172a; border:1px solid #273453; padding:6px 10px; border-radius:999px; display:inline-flex; gap:8px; align-items:center; color:#e8eefc }
              .warn { border-color:#ff5e6c; color:#ffd6da; background:#2a0f15 }
              .btn { background:linear-gradient(180deg,#3b82f6,#2563eb); color:white; border:none; border-radius:10px; padding:10px 16px; font-weight:700; cursor:pointer; box-shadow:0 5px 14px rgba(37,99,235,.35) }
              canvas { width:100%; height:320px; display:block; background:#0d1322; border:1px solid #1b2235; border-radius:12px }
              .plot-head { display:flex; justify-content:space-between; align-items:center; font-size:13px; color:#a8b2c8; margin:6px 2px 8px }
              .legend { display:inline-flex; gap:12px; align-items:center }
              .lg { display:inline-flex; gap:6px; align-items:center }
              .swatch { width:18px; height:4px; background:#bfc7d9; border-radius:2px }
              .dashed { border-bottom:2px dashed #2b84ff; background:transparent; height:0 }
              .recon { background:#2b84ff; height:4px }
              .dot { width:10px; height:10px; background:#ff3b3b; border-radius:50%; outline:2px solid #ffd2d2 }
              .note { font-size:12px; color:#a8b2c8; margin-top:6px }
              .toggles { display:flex; flex-wrap:wrap; gap:10px 12px; align-items:center; padding:10px 12px }
              .toggle { display:inline-flex; gap:8px; align-items:center; background:#121828; border:1px solid #1b2235; border-radius:8px; padding:6px 10px }
              @media (max-width:900px){ .control { grid-column:span 12 } }
            `}</style>

            <h1>Amostragem e Nyquist</h1>

            <div className="panel">
              <div className="controls" role="group" aria-label="Controles principais">
                <div className="control" title="Define quantas amostras por segundo são coletadas">
                  <label htmlFor="fs">Frequência de amostragem Fs em Hz</label>
                  <input id="fs" type="range" min={0} max={400} value={Fs} step={1} onChange={e => setFs(Number(e.target.value))} aria-label="Slider Fs" />
                  <input id="fsNum" type="number" min={0} max={400} step={1} value={Fs} onChange={e => setFs(clamp(Number(e.target.value), 0, 400))} aria-label="Entrada numérica Fs" />
                </div>

                <div className="control" title="Define a frequência da senoide analógica">
                  <label htmlFor="f">Frequência do sinal f em Hz</label>
                  <input id="f" type="range" min={0} max={100} value={f} step={1} onChange={e => setF(Number(e.target.value))} aria-label="Slider f" />
                  <input id="fNum" type="number" min={0} max={100} step={1} value={f} onChange={e => setF(clamp(Number(e.target.value), 0, 100))} aria-label="Entrada numérica f" />
                </div>

                <div className="control" title="Define a fase inicial da senoide em graus">
                  <label htmlFor="phase">Fase do sinal em graus</label>
                  <input id="phase" type="range" min={0} max={360} value={phase} step={1} onChange={e => setPhase(Number(e.target.value))} aria-label="Slider fase" />
                  <input id="phaseNum" type="number" min={0} max={360} step={1} value={phase} onChange={e => setPhase(clamp(Number(e.target.value), 0, 360))} aria-label="Entrada numérica fase" />
                </div>

                <div className="control" title="Define a janela de tempo do sinal">
                  <label htmlFor="win">Janela de tempo T em s</label>
                  <input id="win" type="range" min={0.2} max={5} value={T} step={0.1} onChange={e => setT(Number(e.target.value))} aria-label="Slider janela de tempo" />
                  <input id="winNum" type="number" min={0.2} max={5} step={0.1} value={T} onChange={e => setT(clamp(Number(e.target.value), 0.2, 5))} aria-label="Entrada numérica janela de tempo" />
                </div>
              </div>

              <div className="row meta">
                <span className={`pill ${Fs === 0 ? '' : ''}`} title="Metade de Fs">Nyquist Fn igual a <strong>{Fs > 0 ? (Fs / 2).toFixed(1) : 'n.d.'} Hz</strong></span>
                <span className={`pill ${Fs > 0 && f > Fs / 2 ? 'warn' : ''}`} title="Frequência percebida após aliasing">f_alias igual a <strong>{Fs > 0 && f > Fs / 2 ? fAlias.toFixed(1) : '0.0'} Hz</strong></span>
                {Fs === 0 && (<span className="pill warn" title="Amostragem desativada">Fs igual a zero desativa amostragem</span>)}
                <span className="pill" title="Status dos testes">{testMsg}</span>
                <button className="btn" onClick={resetAll} title="Voltar aos padrões">Reset</button>
              </div>

              <div className="row radios" role="radiogroup" aria-label="Modo de reconstrução">
                <label title="Somente os pontos amostrados">
                  <input type="radio" name="mode" value="none" checked={mode === 'none'} onChange={() => setMode('none')} /> Nenhum
                </label>
                <label title="Interpolação por segmentos de reta">
                  <input type="radio" name="mode" value="linear" checked={mode === 'linear'} onChange={() => setMode('linear')} /> Linear
                </label>
                <label title="Interpolação spline cúbica natural">
                  <input type="radio" name="mode" value="spline" checked={mode === 'spline'} onChange={() => setMode('spline')} /> Spline cúbica
                </label>
                <label title="Convolução com núcleo sinc janela Blackman">
                  <input type="radio" name="mode" value="lpf" checked={mode === 'lpf'} onChange={() => setMode('lpf')} /> Filtro passa baixas
                </label>
              </div>

              <div className="toggles" aria-label="Visibilidade do gráfico">
                <span className="pill">Camadas</span>
                <label className="toggle"><input type="checkbox" checked={visBottom.analog} onChange={e => setVisBottom(v => ({...v, analog: e.target.checked}))} /> Analógico</label>
                <label className="toggle"><input type="checkbox" checked={visBottom.samples} onChange={e => setVisBottom(v => ({...v, samples: e.target.checked}))} /> Amostras</label>
                <label className="toggle"><input type="checkbox" checked={visBottom.recon} onChange={e => setVisBottom(v => ({...v, recon: e.target.checked}))} /> Reconstrução</label>
              </div>

              <div className="row">
                <div className="plot-head">
                  <div>Reconstrução e referência</div>
                  <div className="legend">
                    <span className="lg"><span className="swatch" style={{background:'#bfc7d9'}}></span> analógico</span>
                    <span className="lg"><span className="dot"></span> amostras</span>
                    <span className="lg" style={{display: mode === 'linear' ? '' : 'none'}}><span className="swatch dashed"></span> linear</span>
                    <span className="lg" style={{display: mode === 'spline' ? '' : 'none'}}><span className="swatch recon"></span> spline</span>
                    <span className="lg" style={{display: mode === 'lpf' ? '' : 'none'}}><span className="swatch recon" style={{height:'6px'}}></span> passa baixas</span>
                  </div>
                </div>
                <canvas ref={plotRef} aria-label="Reconstrução e referência"></canvas>
                <div className="note">Eixo x em segundos e eixo y em amplitude. O gráfico ajusta a escala automaticamente</div>
              </div>
            </div>
          </div>
        )
      }

      const root = ReactDOM.createRoot(document.getElementById('root'))
      root.render(<App />)
    </script>
  </body>
</html>

